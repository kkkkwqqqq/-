# 2022暑期面试八股文

## Mybaits相关

> 什么是 Mybatis？

- Mybatis 是一个`半 ORM`（对象关系映射）框架，它内部封装了 JDBC，开发时
  只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建
  statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制 sql 执行性能，灵活度高。
- MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO 映射成数
  据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。
- 通过 xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过
  java 对象和 statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句，最
  后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。（从执行 sql 到返
  回 result 的过程）。

`补充：Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 Mybatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。`

> Mybaits 的优点：

- 基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任
  何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML
  标签，支持编写动态 SQL 语句，并可重用。
- 与 JDBC 相比，减少了 50%以上的代码量，消除了 JDBC 大量冗余的代码，不
  需要手动开关连接；
- 很好的与各种数据库兼容（因为 MyBatis 使用 JDBC 来连接数据库，所以只要
  JDBC 支持的数据库 MyBatis 都支持）。
- 能够与 Spring 很好的集成；
- 提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射
  标签，支持对象关系组件维护。



> MyBatis 框架的缺点：

- SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写
  SQL 语句的功底有一定要求。
- SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。
- 

> MyBatis 框架适用场合：

- MyBatis 专注于 SQL 本身，是一个足够灵活的 DAO 层解决方案。
- 对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis 将是
  不错的选择。





> 6、#{}和${}的区别是什么？

- #{}是预编译处理，${}是字符串替换。
- Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的
  set 方法来赋值；
- Mybatis 在处理${}时，就是把${}替换成变量的值。
- 使用#{}可以有效的防止 SQL 注入，提高系统安全性。



> 当实体类中的属性名和表中的字段名不一样 ，怎么办 ？

第 1 种： 通过在查询的 sql 语句中定义字段名的别名，让字段名的别名和实体类
的属性名一致。

```html
<select id=”selectorder” parametertype=”int” resultetype=”
me.gacl.domain.order”>
select order_id id, order_no orderno ,order_price price form
orders where order_id=#{id};
</select>
```



第 2 种： 通过<resultMap>来映射字段名和实体类属性名的一一对应的关系

```html
<select id="getOrder" parameterType="int"
resultMap="orderresultmap">
select * from orders where order_id=#{id}
</select>
<resultMap type=”me.gacl.domain.order” id=”orderresultmap”>
<!–用 id 属性来映射主键字段–>
<id property=”id” column=”order_id”>
<!–用 result 属性来映射非主键字段，property 为实体类属性名，column
为数据表中的属性–>
<result property = “orderno” column =”order_no”/>
<result property=”price” column=”order_price” />
</reslutMap>
```



>  模糊查询 like 语句该怎么写?

第 1 种：在 Java 代码中添加 sql 通配符。

```html
string wildcardname = “%smi%”;
list<name> names = mapper.selectlike(wildcardname);

<select id=”selectlike”>
select * from foo where bar like #{value}
</select>
```

第 2 种：在 sql 语句中拼接通配符

```html

string wildcardname = “smi”;
list<name> names = mapper.selectlike(wildcardname);
<select id=”selectlike”>
select * from foo where bar like "%"#{value}"%"
</select>
```



> 通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，
> 请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，
> 参数不同时，方法能重载吗？

![image-20220414090500320](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204140905675.png)

​		Dao 接口即 Mapper 接口。接口的全限名，就是映射文件中的 namespace 的值；
接口的方法名，就是映射文件中 Mapper 的 Statement 的 id 值；接口方法内的
参数，就是传递给 sql 的参数。

​		Mapper 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符
串作为 key 值，可唯一定位一个 MapperStatement。在 Mybatis 中

```
每一个
<select>、<insert>、<update>、<delete>标签，都会被解析为一个
MapperStatement 对象。
```

​		举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯
一找到 namespace 为 com.mybatis3.mappers.StudentDao 下面 id 为
findStudentById 的 MapperStatement。



​		Mapper 接口里的方法，是不能重载的，因为是使用 全限名+方法名 的保存和寻
找策略。Mapper 接口的工作原理是 JDK 动态代理，Mybatis 运行时会使用 JDK
动态代理为 Mapper 接口生成代理对象 proxy，代理对象会拦截接口方法，转而
执行 MapperStatement 所代表的 sql，然后将 sql 执行结果返回。



> Mybatis 是如何进行分页的？分页插件的原理是什么？

​		Mybatis 使用 `RowBounds` 对象进行分页，它是针对 ResultSet 结果集执行的内
存分页，而非物理分页。可以在 sql 内直接书写带有物理分页的参数来完成物理分
页功能，也可以使用分页插件来完成物理分页。

​		分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义插件，在插件
的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物
理分页语句和物理分页参数。



> Mybatis是如何将sql执行结果封装为目标对象并返回的？
> 都有哪些映射形式？

第一种是使用<resultMap>标签，逐一定义数据库列名和对象属性名之间的映
射关系。

第二种是使用 sql 列的别名功能，将列的别名书写为对象属性名

有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给
对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。



> 如何获取自动生成的(主)键值?

insert 方法总是返回一个 int 值 ，这个值代表的是插入的行数。
如果采用自增长策略，自动生成的键值在 insert 方法执行完后可以被设置到传入
的参数对象中。
示例：

```xml
<insert id=”insertname” usegeneratedkeys=”true” keyproperty=”
id”>
insert into names (name) values (#{name})
</insert>
name name = new name();
name.setname(“fred”);
int rows = mapper.insertname(name);
// 完成后,id 已经被设置到对象中
system.out.println(“rows inserted = ” + rows);
system.out.println(“generated key value = ” + name.getid());
```



> 在 mapper 中如何传递多个参数?

DAO 层的函数

```java
public UserselectUser(String name,String area);
对应的 xml,#{0}代表接收的是 dao 层中的第一个参数，#{1}代表 dao 层中第二
参数，更多参数一致往后加即可。
```

```xml
<select id="selectUser"resultMap="BaseResultMap">
select * fromuser_user_t whereuser_name = #{0}
anduser_area=#{1}
</select>
```

第二种： 使用 @param 注解:

```java
public interface usermapper {
user selectuser(@param(“username”) string
username,@param(“hashedpassword”) string hashedpassword);
}
```

然后,就可以在 xml 像下面这样使用(推荐封装为一个 map,作为单个参数传递给
mapper):

```xml
<select id=”selectuser” resulttype=”user”>
select id, username, hashedpassword
from some_table
where username = #{username}
and hashedpassword = #{hashedpassword}
</select>

```

第三种：多个参数封装成 map

```java
try {
//映射文件的命名空间.SQL 片段的 ID，就可以调用对应的映射文件中的
SQL
//由于我们的参数超过了两个，而方法中只有一个 Object 参数收集，因此
我们使用 Map 集合来装载我们的参数
Map < String, Object > map = new HashMap();
map.put("start", start);
map.put("end", end);
return sqlSession.selectList("StudentID.pagination", map);
} catch (Exception e) {
e.printStackTrace();
sqlSession.rollback();
throw e;
} finally {
MybatisUtil.closeSqlSession();
}
```

> Mybatis 动态 sql 有什么用？执行原理？有哪些动态 sql？

​	Mybatis 动态 sql 可以在 Xml 映射文件内，以标签的形式编写动态 sql，

执行原理
是根据表达式的值 完成逻辑判断并动态拼接 sql 的功能。

​	Mybatis 提供了 9 种动态 sql 标签：trim | where | set | foreach | if | choose
| when | otherwise | bind。



> Xml 映射文件中，除了常见的 select|insert|updae|delete
> 标签之外，还有哪些标签？

答：<resultMap>、<parameterMap>、<sql>、<include>、
<selectKey>，加上动态 sql 的 9 个标签，其中<sql>为 sql 片段标签，通过
<include>标签引入 sql 片段，<selectKey>为不支持自增的主键生成策略标
签。



> Mybatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？

不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配
置 namespace，那么 id 不能重复；



原因就是 namespace+id 是作为 Map<String, MapperStatement>的 key
使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。
有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然
也就不同。



> 为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动
> 的区别在哪里？

Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联
集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 Mybatis
在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自
动 ORM 映射工具。



> Mybatis 是否支持延迟加载？如果支持，它的实现原理是
> 什么？   ==应该不会问==

Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加
载，association 指的就是一对一或者一对多，collection 指的就是一对多查询。在 Mybatis
配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled=true|false。



它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦
截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是
null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，
然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()
方法的调用。这就是延迟加载的基本原理。

  

当然了，不光是 Mybatis，几乎所有的包括 Hibernate，支持延迟加载的原理都
是一样的。



> Mybatis 的一级、二级缓存:

一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为
Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就
将清空，默认打开一级缓存。



二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap
存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，
如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要
实现 Serializable 序列化接口(可用来保存对象的状态),可在它的映射文件中配置
<cache/> ；

![image-20220415170544266](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204151705480.png)

对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存
Namespaces)的进行了 C/U/D 操作后，默认该作用域下所有 select 中的缓存将
被 clear。



> 什么是 MyBatis 的接口绑定？有哪些实现方式？==1==

接口绑定，就是在 MyBatis 中任意定义接口,然后把接口里面的方法和 SQL 语句绑
定, 我们直接调用接口方法就可以,这样比起原来了 SqlSession 提供的方法我们可
以有更加灵活的选择和设置。



接口绑定有两种实现方式,一种是通过注解绑定，就是在接口的方法上面加上
@Select、@Update 等注解，里面包含 Sql 语句来绑定；另外一种就是通过 xml
里面写 SQL 来绑定, 在这种情况下,要指定 xml 映射文件里面的 namespace 必须
为接口的全路径名。当 Sql 语句比较简单时候,用注解绑定, 当 SQL 语句比较复杂
时候,用 xml 绑定,一般用 xml 绑定的比较多。



> 使用 MyBatis 的 mapper 接口调用时有哪些要求？

Mapper 接口方法名和 mapper.xml 中定义的每个 sql 的 id 相同；

Mapper 接口方法的输入参数类型和 mapper.xml 中定义的每个 sql 的
parameterType 的类型相同；

Mapper 接口方法的输出参数类型和 mapper.xml 中定义的每个 sql 的
resultType 的类型相同；

Mapper.xml 文件中的 namespace 即是 mapper 接口的类路径。



> 简述 Mybatis 的插件运行原理，以及如何编写一个插件。

Mybatis 仅可以编写针对 ParameterHandler、ResultSetHandler、
StatementHandler、Executor 这 4 种接口的插件，Mybatis 使用 JDK 的动态代
理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种
接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 invoke()
方法，当然，只会拦截那些你指定需要拦截的方法。

编写插件：实现 Mybatis 的 Interceptor 接口并复写 intercept()方法，然后在给
插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文
件中配置你编写的插件。



## Java面试题

> 面向对象的特征有哪些方面？

抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽
象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的
细节是什么。

继承：继承是从已有类得到继承信息创建新类的过程。是对父类的一种扩展机制

封装：我们在类中编写的方法就是对实现细节的一种封装；我们编写
一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，
只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，
明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是
封装得足够好的，因为几个按键就搞定了所有的事情）。

多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。
简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。



> float f=3.4;是否正确？

答:不正确。3.4 是double类型，f是float，将double赋值给float属于
下转型（down-casting，也称为窄化），因此需要强制类型转换
float f =(float)3.4; 或者写成 float f =3.4F;。但是当右边的数不是3.4而是包含很大小数的一个数的话，强转会造成精度损失

> short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;
> 有错吗？

对于 short s1 = 1; s1 = s1 + 1;会出现编译报错，由于 1 是 int 类型，因此 s1+1 运算结果也是 int
型，需要强制转换类型才能赋值给 short 型。而 short s1 = 1; s1 += 1;可以正确
编译，因为 s1+= 1;相当于 s1 = (short)(s1 + 1);其中有隐含的强制类型转换。



> int 和 Integer 有什么区别？

为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，
从 Java 5 开始引入了自动装箱/拆箱机制，使得二者可以相互转换。
Java 为每个原始类型提供了包装类型：

![image-20220414110820947](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204141108359.png)

![image-20220414110837261](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204141108445.png)

最近还遇到一个面试题，也是和自动装箱和拆箱有点关系的，代码如下所示：

![image-20220414110908466](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204141109570.png)

如果不明就里很容易认为两个输出要么都是 true 要么都是 false。首先需要注意的
是 f1、f2、f3、f4 四个变量都是 Integer 对象引用，所以下面的==运算比较的不
是值而是引用。装箱的本质是什么呢？当我们给一个 Integer 对象赋一个 int 值的
时候，会调用 Integer 类的静态方法 valueOf，如果看看 valueOf 的源代码就知
道发生了什么。

![image-20220414110932647](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204141109843.png)

IntegerCache 是 Integer 的内部类，其代码如下所示：

![image-20220414120418891](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204141204108.png)

![image-20220414120444536](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204141204632.png)



> &和&&的区别？

&运算符有两种用法：(1)按位与；(2)逻辑与。&&运算符是短路与运算。逻辑与
跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是
true 整个表达式的值才是 true。&&之所以称为短路运算是因为，如果&&左边的
表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。很多时候我
们可能都需要用&&而不是&，例如在验证用户登录时判定用户名不是 null 而且不
是空字符串，应当写为：username != null &&!username.equals(“”)，二者
的顺序不能交换，更不能用&运算符，因为第一个条件如果不成立，根本不能进行
字符串的 equals 比较，否则会产生 NullPointerException 异常。注意：逻辑或
运算符（|）和短路或运算符（||）的差别也是如此。参考博客：[(13条消息) Java中&、|、&&、||详解_奋斗的小程序员的博客-CSDN博客_& java](https://blog.csdn.net/sum_tw/article/details/55683186)



> 解释内存中的栈(stack)、堆(heap)和方法区(method area)
> 的用法。

通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的
现场保存都使用 JVM 中的栈空间；而通过 new 关键字和构造器创建的对象则放在
堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收
集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为 Eden、
Survivor（又可分为 From Survivor 和 To Survivor）、Tenured；方法区和堆都
是各个线程共享的内存区域，用于存储已经被 JVM 加载的类信息、常量、静态变
量、JIT 编译器编译后的代码等数据；程序中的字面量（literal）如直接书写的 100、”
hello”和常量都是放在常量池中，常量池是方法区的一部分，。栈空间操作起来
最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过 JVM
的启动参数来进行调整，栈空间用光了会引发 StackOverflowError，而堆和常量
池空间不足则会引发 OutOfMemoryError。

String str = new String("hello");

上面的语句中变量 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而”
hello”这个字面量是放在方法区的。

补充 1：较新版本的 Java（从 Java 6 的某个更新开始）中，由于 JIT 编译器的发
展和”逃逸分析”技术的逐渐成熟，栈上分配、标量替换等优化技术使得对象一
定分配在堆上这件事情已经变得不那么绝对了。

补充 2：运行时常量池相当于 Class 文件常量池具有动态性，Java 语言并不要求
常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String
类的 intern()方法就是这样的。

看看下面代码的执行结果是什么并且比较一下 Java 7 以前和以后的运行结果是否
一致。

![image-20220414121743803](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204141217991.png)

==扩展==

![image-20220415235821873](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204152358208.png)

> 是否可以继承 String 类？

String 类是 final 类，不可以被继承。



> 10、Math.round(11.5) 等于多少？Math.round(-11.5)等于
> 多少？

Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍五
入的原理是在参数上加 0.5 然后进行下取整。



> switch 是否能作用在 byte 上，是否能作用在 long 上，
> 是否能作用在 String 上？

在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从 Java
5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，
expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是
不可以的。



> 用最有效率的方法计算 2 乘以 8？

2 << 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。



> 数组有没有 length()方法？String 有没有 length()方法？

数组没有 length()方法，有 length 的属性。String 有 length()方法。



> 在 Java 中，如何跳出当前的多重嵌套循环？

![image-20220415183316124](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204151833185.png)

在最外层循环前加一个标记如 A，然后用 break A;可以跳出多重循环。



> 构造器（constructor）是否可被重写（override）？

构造器不能被继承，因此不能被重写，但可以被重载。



> 两个对象值相同(x.equals(y) == true)，但却可有不同的
> hash code，这句话对不对？

不对，如果两个对象 x 和 y 满足 x.equals(y) == true，它们的哈希码（hash code）
应当相同。Java 对于 eqauls 方法和 hashCode 方法是这样规定的：

(1)如果两个对象相同（equals 方法返回 true），那么它们的 hashCode 值一定要相同；

(2)
如果两个对象的 hashCode 相同，它们并不一定相同。当然，你未必要按照要求
去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现
在 Set 集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，
如果哈希码频繁的冲突将会造成存取性能急剧下降）。

参考文章：[为什么 Java 中重写 equals 一定要重写 hashCode | Cimoc](https://cimoc.cn/2022/03/03/java-equals-and-hashcode/)



> 当一个对象被当作参数传递到一个方法后，此方法可改变
> 这个对象的属性，并可返回变化后的结果，那么这里到底是值传
> 递还是引用传递？

是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个
参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调
用过程中被改变，但对对象引用的改变是不会影响到调用者的。

详解可参考：[(15条消息) Java是值传递还是引用传递？还是两者皆有？_小夏陌的博客-CSDN博客_java是值传递还是引用传递](https://blog.csdn.net/qq_22136439/article/details/122875110)



> String 和 StringBuilder、StringBuffer 的区别？

Java 平台提供了两种类型的字符串：String 和 StringBuffer/StringBuilder，它
们可以储存和操作字符串。其中 ==String 是只读字符串，==也就意味着 String 引用的
==字符串内容是不能被改变的。而 StringBuffer/StringBuilder 类表示的字符串对象
可以直接进行修改。==StringBuilder 是 Java 5 中引入的，==它和 StringBuffer 的方
法完全相同==，`区别在于它是在单线程环境下使用的，因为它的所有方面都没有被
synchronized 修饰，因此它的效率也比 StringBuffer 要高。`

`面试题 1 `- 什么情况下用+运算符进行字符串连接比调用
StringBuffer/StringBuilder 对象的 append 方法连接字符串性能更好？

==**如果使用少量的字符串操作，使用 (+运算符)连接字符串；
如果频繁的对大量字符串进行操作StringBuffer/StringBuilder**==

`面试题 2 `- 请说出下面程序的输出。

![image-20220415190213473](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204151902564.png)

==输出：false
true
false
true
false==

补充：解答上面的面试题需要清除两点：

1. String 对象的 intern 方法会得到字符
    串对象在常量池中对应的版本的引用（如果常量池中有一个字符串与 String 对象
    的 equals 结果是 true），如果常量池中没有对应的字符串，则该字符串将被添加
    到常量池中，然后返回常量池中字符串的引用；
2. 2. 字符串的+操作其本质是创建
      了 StringBuilder 对象进行 append 操作，然后将拼接后的 StringBuilder 对象用
      toString 方法处理成 String 对象



> 重载（Overload）和重写（Override）的区别。重载的
> 方法能否根据返回类型进行区分？

方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，
而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同
的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返
回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里
氏代换原则）。重载对返回类型没有特殊的要求。



> ==**描述一下 JVM 加载 class 文件的原理机制？**==

JVM 中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java 中的
类加载器是一个重要的 Java 运行时系统组件，它负责在运行时查找和装入类文件
中的类。

由于 Java 的跨平台性，经过编译的 Java 源程序并不是一个可执行程序，而是一
个或多个类文件。当 Java 程序需要使用某个类时，JVM 会确保这个类已经被加载、
连接（验证、准备和解析）和初始化。类的加载是指把类的.class 文件中的数据读
入到内存中，通常是创建一个字节数组读入.class 文件，然后产生与所加载类对应
的 Class 对象。加载完成后，Class 对象还不完整，所以此时的类还不可用。当类
被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设
置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后 JVM 对
类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么
就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。
类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加
载器（Extension）、系统加载器（System）和用户自定义类加载器

（java.lang.ClassLoader 的子类）。从 Java 2（JDK 1.2）开始，类加载过程采
取了父亲委托机制（PDM）。PDM 更好的保证了 Java 平台的安全性，在该机制
中，JVM 自带的 Bootstrap 是根加载器，其他的加载器都有且仅有一个父类加载
器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM 不会向 Java 程序提供对 Bootstrap 的引用。下面是关于几个类
加载器的说明：

-  Bootstrap：一般用本地代码实现，负责加载 JVM 基础核心类库（rt.jar）；
-  Extension：从 java.ext.dirs 系统属性所指定的目录中加载类库，它的父
  加载器是 Bootstrap；
- System：又叫应用类加载器，其父类是 Extension。它是应用最广泛的
  类加载器。它从环境变量 classpath 或者系统属性 java.class.path 所指定的目
  录中记载类，是用户自定义加载器的默认父加载器。



> char 型变量中能不能存贮一个中文汉字，为什么？

char 类型可以存储一个中文汉字，因为 Java 中使用的编码是 Unicode（不选择
任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一
个 char 类型占 2 个字节（16 比特），所以放一个中文是没问题的。



> 抽象类（abstract class）和接口（interface）有什么异
> 同？

抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如
果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实
现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中
可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其
中的方法全部都是抽象方法。抽象类中的成员可以是 private、默认、protected、
public 的，而接口中的成员全都是 public 的。抽象类中可以定义成员变量，而接
口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而
抽象类未必要有抽象方法



> 静态嵌套类(Static Nested Class)和内部类（Inner Class）
> 的不同？

Static Nested Class 是被声明为静态（static）的内部类，它可以不依赖于外部类
实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。

==**案例：**==

```
package fuxi;

public class Test {
    private int a=1;

    public int getA() {
        return a;
    }

    public void setA(int a) {
        this.a = a;
    }

    public class Test1{
        private int b=2;

        public int getB() {
            return b;
        }

        public void setB(int b) {
            this.b = b;
        }
    }
    public static class Test2{
        private int c=3;

        public int getC() {
            return c;
        }

        public void setC(int c) {
            this.c = c;
        }
    }

}
```

```
package fuxi;

public class Main {
    public static void main(String[] args) {
        Test test = new Test();
        Test.Test2 test2 = new Test.Test2();
        Test.Test1 test1 = test.new Test1();    //依赖于外部类的实例test 才能new出来
        System.out.println(test.getA());
        System.out.println(test1.getB());
        System.out.println(test2.getC());

    }
}
```

> 输出：

![image-20220416235900531](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204162359205.png)

> 面试题 - 下面的代码哪些地方会产生编译错误？

![](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204170001323.png)

注意：Java 中非静态内部类对象的创建要依赖其外部类对象，上面的面试题中 foo
和 main 方法都是静态方法，静态方法中没有 this，也就是说没有所谓的外部类对
象，因此无法创建内部类对象，如果要在静态方法中创建内部类对象，可以这样
做：

```shell 
new Outer().new Inner();
```



> 抽象的（abstract）方法是否可同时是静态的（static）,
> 是否可同时是本地方法（native），是否可同时被 synchronized
> 修饰？

都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛
盾的。本地方法是由本地代码（如 C 代码）实现的方法，而抽象方法是没有实现
的，也是矛盾的。synchronized 和方法的实现细节有关，抽象方法不涉及实现细
节，因此也是相互矛盾的。



> Java 中会存在内存泄漏吗，请简单描述。

理论上 Java 因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是 Java 被
广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无
用但可达的对象，这些对象不能被 GC 回收，因此也会导致内存泄露的发生。

> 阐述静态变量和实例变量的区别。

静态变量是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的
任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷
贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。
静态变量可以实现让多个对象共享内存。



> 是否可以从一个静态（static）方法内部发出对非静态
> （non-static）方法的调用？

==**不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在
调用静态方法时可能对象并没有被初始化。**==



> 如何实现对象克隆？

有两种方式：
1). 实现 Cloneable 接口并重写 Object 类中的 clone()方法；
2). 实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真
正的深度克隆，代码如下。

> GC 是什么？为什么要有 GC？





> 接口是否可继承（extends）接口？抽象类是否可实现
> （implements）接口？抽象类是否可继承具体类（concrete
> class）？

接口可以继承接口，而且支持`多重继承`。抽象类可以实现(implements)接口，抽
象类可继承具体类也可以继承抽象类。

补充：类与类之间只支持单继承



> String s = new String(“xyz”);创建了几个字符串对象？

两个对象，一个是静态区的”xyz”，一个是用 new 创建在堆上的对象。



> 一个”.java”源文件中是否可以包含多个类（不是内部类）？
> 有什么限制？

可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和
公开类的类名完全保持一致。

![image-20220417002638659](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204170026731.png)

> Anonymous Inner Class(匿名内部类)是否可以继承其它
> 类？是否可以实现接口？

==**可以继承其他类或实现其他接口，在 Swing 编程和 Android 开发中常用此方式来
实现事件监听和回调。**==



> 内部类可以引用它的包含类（外部类）的成员吗？有没有
> 什么限制？

==**一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。**==



> Java 中的 final 关键字有哪些用法？

(1)修饰类：表示该类不能被继承；(2)修饰方法：表示方法不能被重写；(3)修饰变
量：表示变量只能一次赋值以后值不能被修改（常量）。

![image-20220417003320872](../AppData/Roaming/Typora/typora-user-images/image-20220417003320872.png)



> 37题





> 如何将字符串转换为基本数据类型？

调用基本数据类型对应的包装类中的方法 parseXXX(String)或
valueOf(String)即可返回相应基本类型；



> 如何将基本数据类型转换为字符串？

一种方法是将基本数据类型与空字符串（”“）连接（+）即可获得其所
对应的字符串；另一种方法是调用 String 类中的 valueOf()方法返回相应字符串



> 如何实现字符串的反转及替换？

方法很多，可以自己写实现也可以使用 String 或 StringBuffer/StringBuilder 中
的方法。有一道很常见的面试题是用递归实现字符串反转，代码如下所示：

![image-20220417003758122](../AppData/Roaming/Typora/typora-user-images/image-20220417003758122.png)



> 怎样将 GB2312 编码的字符串转换为 ISO-8859-1 编码的
> 字符串？

![image-20220417003929377](../AppData/Roaming/Typora/typora-user-images/image-20220417003929377.png)





> 如何取得年月日、小时分钟秒？

```
import java.time.LocalDateTime;
import java.util.Calendar;

public class DateTimeTest {
    public static void main(String[] args) {
        Calendar cal = Calendar.getInstance();
        System.out.println(cal.get(Calendar.YEAR));
        System.out.println(cal.get(Calendar.MONTH)); // 0 - 11
        System.out.println(cal.get(Calendar.DATE));
        System.out.println(cal.get(Calendar.HOUR_OF_DAY));
        System.out.println(cal.get(Calendar.MINUTE));
        System.out.println(cal.get(Calendar.SECOND));
// Java 8
        LocalDateTime dt = LocalDateTime.now();
        System.out.println(dt.getYear());
        System.out.println(dt.getMonthValue()); // 1 - 12
        System.out.println(dt.getDayOfMonth());
        System.out.println(dt.getHour());
        System.out.println(dt.getMinute());
        System.out.println(dt.getSecond());
    }
}

```

> 如何取得从 1970 年 1 月 1 日 0 时 0 分 0 秒到现在的毫秒数？

```
Calendar.getInstance().getTimeInMillis();
System.currentTimeMillis();
long millis = Clock.systemDefaultZone().millis();// Java 8
```



> 如何取得某月的最后一天？

```
Calendar time = Calendar.getInstance();
time.getActualMaximum(Calendar.DAY_OF_MONTH);
```

> 如何格式化日期？

利用 java.text.DataFormat 的子类（如 SimpleDateFormat 类）中的
format(Date)方法可将日期格式化。Java 8 中可以用
java.time.format.DateTimeFormatter 来格式化时间日期，代码如下所示。

```java
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.Date;

class DateFormatTest {
    public static void main(String[] args) {
        SimpleDateFormat oldFormatter = new
                SimpleDateFormat("yyyy/MM/dd");
        Date date1 = new Date();
        System.out.println(oldFormatter.format(date1));
// Java 8
        DateTimeFormatter newFormatter =
                DateTimeFormatter.ofPattern("yyyy/MM/dd");
        LocalDate date2 = LocalDate.now();
        System.out.println(date2.format(newFormatter));
    }
}
```

![image-20220417225622225](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204172256413.png)



> 打印昨天的当前时刻。

![image-20220417004132409](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204170041483.png)

```
Sat Apr 16 00:44:49 CST 2022
```

![image-20220417004143686](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204170041819.png)

```
2022-04-16T00:45:46.723
```





> Error 和 Exception 有什么区别？

Error 表示==系统级的错误和程序不必处理的异常==；比如内存溢出，不可能指望程序能处理这样的情况；
Exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；
也就是说，它表示如果程序运行正常，从不会发生的情况。



> try{}里有一个 return 语句，那么紧跟在这个 try 后的
> finally{}里的代码会不会被执行，什么时候被执行，在 return
> 前还是后?

会执行，在方法返回调用者前执行。

![image-20220417122638736](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204171226834.png)

![image-20220417122826394](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204171228480.png)



> Java 语言如何进行异常处理，关键字：throws、throw、
> try、catch、finally 分别如何使用？

Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了
良好的接口。在 Java 中，每个异常都是一个对象，它是 Throwable 类或其子类
的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java 的异常处理
是通过 5 个关键词来实现的：try、catch、throw、throws 和 finally。一般情况
下是用 try 来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过
它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；try 用
来指定一块预防所有异常的程序；catch 子句紧跟在 try 块后面，用来指定你想要
捕获的异常的类型；throw 语句用来明确地抛出一个异常；throws 用来声明一个
方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；finally 为确保一段
代码不管发生什么异常状况都要被执行；try 语句可以嵌套，每当遇到一个 try 语
句，异常的结构就会被放入异常栈中，直到所有的 try 语句都完成。如果下一级的
try 语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这
种异常的 try 语句或者最终将异常抛给 JVM。



> Java 语言如何进行异常处理，关键字：throws、throw、
> try、catch、finally 分别如何使用？

Java 的异常处理
是通过 5 个关键词来实现的：try、catch、throw、throws 和 finally。一般情况
下是用 try 来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过
它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；try 用
来指定一块预防所有异常的程序；catch 子句紧跟在 try 块后面，用来指定你想要
捕获的异常的类型；throw 语句用来明确地抛出一个异常；throws 用来声明一个
方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；finally 为确保一段
代码不管发生什么异常状况都要被执行；





> 列出一些你常见的运行时异常？

- ArithmeticException（算术异常）
-  ClassCastException （类转换异常）
-  IllegalArgumentException （非法参数异常）
-  IndexOutOfBoundsException （下标越界异常）
- NullPointerException （空指针异常）
- SecurityException （安全异常）



> 阐述 final、finally、finalize 的区别。

- final：修饰符（关键字）有三种用法：如果一个类被声明为 final，意味
  着它不能再派生出新的子类，即不能被继承，因此它和 abstract 是反义词。将
  变量声明为 final，可以保证它们在使用中不被改变，被声明为 final 的变量必须
  在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为 final 的方
  法也同样只能使用，不能在子类中被重写。
- finally：通常放在 try…catch…的后面构造总是执行代码块，这就意味着
  程序无论正常执行还是发生异常，这里的代码只要 JVM 不关闭都能执行，可以
  将释放外部资源的代码写在 finally 块中。
- finalize：Object 类中定义的方法，Java 中允许使用 finalize()方法在垃
  圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收
  集器在销毁对象时调用的，通过重写 finalize()方法可以整理系统资源或者执行其他清理工作。



> 类 ExampleA 继承 Exception，类 ExampleB 继承
> ExampleA。

![image-20220417123348298](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204171233372.png)

输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，
抓取 ExampleA 类型异常的 catch 块能够抓住 try 块中抛出的 ExampleB 类型的
异常）





> List、Set、Map 是否继承自 Collection 接口？

List、Set 是，Map 不是。Map 是键值对映射容器，与 List 和 Set 有明显的区别，
而 Set 存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List
是线性结构的容器，适用于按数值索引访问元素的情形。

![image-20220417123815321](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204171238413.png)



> ==**阐述 ArrayList、Vector、LinkedList 的存储性能和特性。**==

ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的
数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉
及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector 中的方法由
于添加了 synchronized 修饰，因此 Vector 是线程安全的容器，但性能上较
ArrayList 差，因此已经是 Java 中的遗留容器。LinkedList 使用双向链表实现存
储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索
引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更
高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本
项的前后项即可，所以插入速度较快。Vector 属于遗留容器（Java 早期的版本中
提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties
都是遗留容器），已经不推荐使用，但是由于 ArrayList 和 LinkedListed 都是非
线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类
Collections 中的 synchronizedList 方法将其转换成线程安全的容器后再使用（这
是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强
实现）。

补充：遗留容器中的 Properties 类和 Stack 类在设计上有严重的问题，Properties
是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个
Hashtable 并将其两个泛型参数设置为 String 类型，但是 Java API 中的
Properties 直接继承了 Hashtable，这很明显是对继承的滥用。这里复用代码的方式应该是 Has-A 关系而不是 Is-A 关系，另一方面容器都属于工具类，继承工具
类本身就是一个错误的做法，使用工具类最好的方式是 Has-A 关系（关联）或
Use-A 关系（依赖）。同理，Stack 类继承 Vector 也是不正确的。Sun 公司的工
程师们也会犯这种低级错误，让人唏嘘不已。



> Collection 和 Collections 的区别？

Collection 是一个接口，它是 Set、List 等容器的父接口；Collections 是个一个
工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、
排序、线程安全化等等。



> List、Map、Set 三个接口存取元素时，各有什么特点？

List 以特定索引来存取元素，可以有重复元素。Set 不能存放重复元素。Map 保存键值对（key-value pair）映射，
映射关系可以是一对一或多对一。



> Thread 类的 sleep()方法和对象的 wait()方法都可以让线
> 程暂停执行，它们有什么区别?

sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程
暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保
持，因此休眠时间结束后会自动恢复（线程回到就绪状态，请参考第 66 题中的线
程状态转换图）。wait()是 Object 类的方法，调用对象的 wait()方法导致当前线
程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用
对象的 notify()方法（或 notifyAll()方法）时才能唤醒等待池中的线程进入等锁池
（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。





> 当一个线程进入一个对象的 synchronized 方法 A 之后，
> 其它线程是否可进入此对象的 synchronized 方法 B？

不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静
态方法上的 synchronized 修饰符要求执行方法时要获得对象的锁，如果已经进入
A 方法说明对象锁已经被取走，那么试图进入 B 方法的线程就只能在等锁池（注
意不是等待池哦）中等待对象的锁。



> 请说出与线程同步以及线程调度相关的方法。

- wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；
- sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用
  此方法要处理 InterruptedException 异常；
- notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并
  不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且
  与优先级无关；
- notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；

[(10条消息) notify() 和 notifyAll() 有什么区别？_ConstXiong的博客-CSDN博客_notifyall](https://blog.csdn.net/meism5/article/details/90238268)



> 编写多线程程序有几种实现方式？

Java 5 以前实现多线程有两种实现方法：一种是继承 Thread 类；另一种是实现
Runnable 接口。两种方式都要通过重写 run()方法来定义线程的行为，推荐使用
后者，因为 Java 中的继承是单继承，一个类有一个父类，如果继承了 Thread 类
就无法再继承其他类了，显然使用 Runnable 接口更为灵活。
补充：Java 5 以后创建线程还有第三种方式：实现 Callable 接口，该接口中的 call
方法可以在线程执行结束时产生一个返回值

> 举例说明同步和异步。

如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正
在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线
程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好
的例子）。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并
且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异
步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻
塞式操作。

> 什么是线程池（thread pool）？

在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内
存资源或者其它更多资源。在 Java 中更是如此，虚拟机将试图跟踪每一个对象，
以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽
可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就
是”池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的
线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完
毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。
Java 5+中的 Executor 接口定义一个执行线程的工具。它的子类型即线程池接口
是 ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理
不是很清楚的情况下，因此在工具类 Executors 面提供了一些静态工厂方法，生
成一些常用的线程池，如下所示：

- newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只
  有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线
  程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执
  行顺序按照任务的提交顺序执行。
- newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创
  建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就
  会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。
- newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小
  超过了处理任务所需要的线程，那么就会回收部分空闲（60 秒不执行任务）的
  线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程
  池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）
  能够创建的最大线程大小。
- newScheduledThreadPool：创建一个大小无限的线程池。此线程池支
  持定时以及周期性执行任务的需求。
- newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持
  定时以及周期性执行任务的需求

> 启动一个线程是调用 run()还是 start()方法？

启动一个线程是调用 start()方法，使线程所代表的虚拟处理机处于可运行状态，
这意味着它可以由 JVM 调度并执行，这并不意味着线程就会立即运行。run()方
法是线程启动后要进行回调（callback）的方法。



> 65 66





> 简述 synchronized 和 java.util.concurrent.locks.Lock
> 的异同？ ==待==

Lock 是 Java 5 以后引入的新的 API，和关键字 synchronized 相比主要相同点：
Lock 能完成 synchronized 所实现的所有功能；主要不同点：Lock 有比
synchronized 更精确的线程语义和更好的性能，而且不强制性的要求一定要获得
锁。synchronized 会自动释放锁，而 Lock 一定要求程序员手工释放，并且最好
在 finally 块中释放（这是释放外部资源的最好的地方）。、、



> 68---74



> 阐述 JDBC 操作数据库的步骤。

![image-20220417132723111](../AppData/Roaming/Typora/typora-user-images/image-20220417132723111.png)

![image-20220417132740056](../AppData/Roaming/Typora/typora-user-images/image-20220417132740056.png)



提示：关闭外部资源的顺序应该和打开的顺序相反，也就是说先关闭 ResultSet、
再关闭 Statement、在关闭 Connection。上面的代码只关闭了 Connection（连
接），虽然通常情况下在关闭连接时，连接上创建的语句和打开的游标也会关闭，
但不能保证总是如此，因此应该按照刚才说的顺序分别关闭。此外，第一步加载
驱动在 JDBC 4.0 中是可以省略的（自动从类路径中加载驱动），但是我们建议保
留。



> 76





> 77

要提升读取数据的性能，可以指定通过结果集（ResultSet）对象的 setFetchSize()
方法指定每次抓取的记录数（典型的空间换时间策略）；要提升更新数据的性能
可以使用 PreparedStatement 语句构建批处理，将若干 SQL 语句置于一个批处
理中执行。



> 78-84



> 什么是 DAO 模式？

DAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了
抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访
问操作。在实际的开发中，应该将所有对数据源的访问操作进行抽象化后封装在
一个公共 API 中。用程序设计语言来说，就是建立一个接口，接口中定义了此应
用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该
类对应一个特定的数据存储。DAO 模式实际上包含了两个模式，一是 Data
Accessor（数据访问器），二是 Data Object（数据对象），前者要解决如何访
问数据的问题，而后者要解决的是如何用对象封装数据。



> sleep和wait

- sleep()和yield()方法是定义在Thread类中，而wait()方法是定义在Object类中的。
- wait()和sleep()的关键的区别在于，==wait()是用于线程间通信的==，而sleep()是用于短时间暂停当前线程。更加明显的一个区别在于，当一个线程调用wait()方法的时候，会释放它锁持有的对象的管程和锁，但是调用sleep()方法的时候，不会释放他所持有的管程。
- wait只能在同步（synchronize）环境中被调用，而sleep不需要。
- 使用sleep方法时，被暂停的线程在被唤醒之后会立即进入就绪态（Runnable state)，但是使用wait方法的时候，被暂停的线程会首先获得锁（译者注：阻塞态），然后再进入就绪态
- 进入wait状态的线程能够被notify和notifyAll线程唤醒，但是进入sleeping状态的线程不能被notify方法唤醒。
-  另一个区别是Thread.sleep()方法是一个静态方法，作用在当前线程上；但是wait方法是一个实例方法，并且只能在其他线程调用本实例的notify()方法时被唤醒。。

- 下图只会输出一句话再300000的时间内 因为sleep不会释放锁，而wait则会立刻输出两句话

![image-20220417170740653](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204171707817.png)







> 线程的 sleep()方法和 yield()方法有什么区别？

① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的
线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的
机会；

② 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转
入就绪（ready）状态；

③ sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异
常；

④ sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性。









> 获得一个类的类对象有哪些方式
>

- 方法 1：类型.class，例如：String.class
- 方法 2：对象.getClass()，例如：”hello”.getClass()
-  方法 3：Class.forName()，例如：Class.forName(“java.lang.String”)



> 如何通过反射创建对象？

- 方法 1：通过类对象调用 newInstance()方法，例如：
  String.class.newInstance()
- 方法 2：通过类对象的 getConstructor()或 getDeclaredConstructor()
  方法获得构造器 前者是公有方法 后者是全部方法

（Constructor）对象并调用其 newInstance()方法创建对象，
例如：String.class.getConstructor(String.class).newInstance(“Hello”);



> 如何通过反射获取和设置对象私有字段的值？

可以通过类对象的 getDeclaredField()方法字段（Field）对象，然后再通过字段
对象的 setAccessible(true)将其设置为可以访问，接下来就可以通过 get/set 方
法来获取/设置字段的值了。

```java
public class User {
    private String name;

    public User() {

    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

```

```java


import javax.jws.soap.SOAPBinding;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

//获得类的信息
public class Test08 {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException, IllegalAccessException, InstantiationException {
        Class c1 = Class.forName("User");

        User instance =(User) c1.newInstance();
        //获得类的名字
        System.out.println(c1.getName()); //获得包名 com.kwq.reflection.User
        System.out.println(c1.getSimpleName());//获得类名 User
        //获得类的属性
        Field[] fields = c1.getFields();//只能找到public属性
         fields = c1.getDeclaredFields();//找到全部的属性
        for (Field field : fields) {
            System.out.println(field);
            /*private java.lang.String com.kwq.reflection.User.name
              private int com.kwq.reflection.User.id
              private int com.kwq.reflection.User.age*/
        }
        //获得指定属性的值
        Field name = c1.getDeclaredField("name");
        name.setAccessible(true);
         name.set(instance,"帅哥");

        System.out.println(name); //private java.lang.String com.kwq.reflection.User.name
        System.out.println(name.get(instance));

    }
}

```

> 输出：

![image-20220417213139561](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204172131719.png)



> 如何通过反射调用对象的方法？

![image-20220417213608456](../AppData/Roaming/Typora/typora-user-images/image-20220417213608456.png)



> 89-90





> 用 Java 写一个单例类。

```java
//饿汉式
public class Singleton1 {
    private Singleton1(){}
    private static Singleton1 instance = new Singleton1();
    public static Singleton1 getInstance(){
        return instance;
    }
}
//懒汉
class Singleton2 {
    private static Singleton2 instance = null;
    private Singleton2() {}
    public static synchronized Singleton2 getInstance(){
        if (instance == null) instance= new Singleton2();
        return instance;
    }
}
```

注意：实现一个单例有两点注意事项，①将构造器私有，不允许外界通过构造器
创建对象；②通过公开的静态方法向外界返回类的唯一实例。这里有一个问题可
以思考：Spring 的 IoC 容器可以为普通的类创建单例，它是怎么做到的呢？

> 手写一个冒泡排序（可以秒写，太容易了）

```
package commonAlgorithm;

public class bubblingSort {

    public static void main(String[] args) {
        int[] arr = {1, 4, 2, 4, 6, 8};
        bubblingSort bubblingSort = new bubblingSort();
        bubblingSort.maopao(arr);
        for (int i : arr) {
            System.out.print(i+" ");
        }

    }
    //冒泡方法 从小到大排序
    public void maopao(int arr[]){
        for(int i=0;i<arr.length-1;i++){
            for (int j=i+1;j<arr.length;j++){
                if (arr[i]>arr[j]){
                    int temp=arr[i];
                    arr[i]=arr[j];
                    arr[j]=temp;
                }
            }
        }
    }


}
```



> 手写一个二分查找

```
package commonAlgorithm;

public class two_Point {
    public static void main(String[] args) {
        int[] arr = {1, 2,2,2, 3, 4,4,4, 5, 6};
        /*two_Point two_point = new two_Point();
        System.out.println(two_point.zheban(arr, 5));*/
        System.out.println(binarySearch(arr, 0, arr.length - 1, 6));

    }

    //非递归
  /*  public int zheban(int arr[],int target){
        int left=0;
        int right = arr.length-1;
        int mid;
        while (left<=right){
            mid=(left+right)/2;
            if (arr[mid]<target){
                left=mid+1;
            }else if (arr[mid]>target){
                right=mid-1;
            }else {
                int temp=mid;
                if (temp>1&&arr[temp]==arr[temp-1]){
                    while (temp>=0&&arr[temp]==target){
                        temp--;
                    }
                    return temp+1;
                }
                return mid;

            }
        }
   return -1; }*/
    //递归实现二分查找
    public static int binarySearch(int[] arr, int left, int right, int target) {
        int mid = (left + right) / 2;
        int midVal = arr[mid];

        if (target > midVal) { // 向右递归
            return binarySearch(arr, mid + 1, right, target);
        } else if (target < midVal) { // 向左递归
            return binarySearch(arr, left, mid - 1, target);
        } else {
            int temp=mid;
            if (temp>1&&arr[temp]==arr[temp-1]){
                while (temp>=0&&arr[temp]==target){
                    temp--;
                }
                return temp+1;
            }
            return mid;
        }


    }
}

```

## Sp


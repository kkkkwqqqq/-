# 设计模式

## 设计模式概述

**设计模式**：是一套用来提高代码可复用性，可维护性、可读性、稳健型以及安全性的解决方案

**设计模式的本质**：是面向对象设计原则的实际运用，是对类的封装、继承、多态以及类的关联关系和组合关系的充分理解。

**设计模式的的基本要素**：模式名称、问题、解决方案、效果

> 分类：

**创建型模式**：（描述怎样去创建一个对象，创建和使用分离）

- **单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式**

**结构型模式**：（描述如何将类或对象安装某种类型组成更大的结构）

- **适配器模式、桥接模式**、装饰模式、组合模式、**外观模式**、享元模式、代理模式

**行为型模式**：（描述类和对象如何可以相互协作）

- **模板方法模式**、命令模式、迭代器模式、**观察者模式**、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式



## OOP七大原则

**开闭原则**：对扩展开发，对修改关闭（`当需求需要改变的时候，尽量去扩展，不修改原来的代码`）

**里氏替换原则**： 继承必须确保超类所拥有的性质在子类中仍然成立（`尽量不重写父类的方法,不然多继承几次，那顶层父类就和本类没啥联系了`）

**依赖倒置原则**： 要面向接口编程，不要面向实现编程。（`抽象不依赖细节，细节依赖抽象,降低程序间的耦合性`）

**单一职责原则**： 控制类的==粒度大小==，将对象解耦，提高其内聚性（一个对象不应该担任太多的职责，原子性，单一的方法做单一的事情,粒度越大说明，这个方法做的事情越多）

**接口隔离原则**： 要为各个类建立他们需要的专用接口

**迪米特法则**： 只与你的直接朋友交谈，不跟“陌生人”说话，降低代码之间的耦合度（比如A->B->C，而不能直接A->C,,controller,service,dao,不能是直接controller->dao,缺点是增加了一个中介，优点是：层次更加清晰，降低耦合度）

**合成复用原则**： 尽量先使用组合或者聚合等关联关系来实现（==内部类==），其次才考虑使用继承关系来实现（如内部类组合外部类，属于has-a关系，但是子类继承则是靠继承关系来实现的属于is-a关系）。==就比如狗和动物应当是继承关系，头和人应当是外部类和内部类的关系==

## 单例模式

核心作用：保证一个类只有一个实例，并且提供一个访问该实例的 全局访问点

> **饿汉式单例模式：**

```
// 饿汉式单例
public class Hungry {

    // 可能会浪费空间 
    private byte[] data1 = new byte[1024*1024];
    private byte[] data2 = new byte[1024*1024];
    private byte[] data3 = new byte[1024*1024];
    private byte[] data4 = new byte[1024*1024];

    // 单例模式核心思想：构造器私有
    private Hungry(){

    }

    private final static Hungry HUNGRY = new Hungry();

    public static Hungry getInstance(){
        return HUNGRY;
    }

}
```

> **DCL懒汉式单例模式：**

```
// 懒汉式单例
public class LazyMan {
    private LazyMan() {
        System.out.println(Thread.currentThread().getName() + "ok");
    }

    private  volatile static LazyMan lazyMan; // volatile 为了避免指令重排

    // 双重检测锁模式的懒汉式单例  DCL 懒汉式
    public static LazyMan getInstance() {
        if (lazyMan == null) {
            synchronized (LazyMan.class) {
                if (lazyMan == null) {
                    lazyMan = new LazyMan();// 不是一个原子性操作
                    /*
                    1、分配内存空间
                    2、执行构造方法，初始化对象
                    3、把这个对象指向这个空间

                    123
                    132 A
                        B // 此时B线程进来会认为lazyman不为null
                          // 直接返回 此时lazyman 还没有完成构造
                          // 为了避免指令重排
                       */
                }
            }
        }

        return lazyMan;
    }
//
//    public static LazyMan getInstance() {
//        if (lazyMan == null) {
//            lazyMan = new LazyMan();
//        }
//        return lazyMan;
//    }

    // 单线程下确实单例ok,但是多线程并发
    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                LazyMan.getInstance();
            }).start();
        }
    }
}
```

**反射 可以破环这种单例**

```
// 懒汉式单例
// 道高一尺，魔高一丈
public class LazyMan {

    private static  boolean qinjiang = false;

    private LazyMan() {
        if(qinjiang == false){
            qinjiang=true;
        }else{
            throw new RuntimeException("不要试图使用反射破坏异常");
        }
//        synchronized (LazyMan.class){
//            if (lazyMan!=null){
//                throw new RuntimeException("不要试图使用反射破坏异常");
//            }
//        }
//        System.out.println(Thread.currentThread().getName() + "ok");
    }

    private  volatile static LazyMan lazyMan; // volatile 为了避免指令重排

    // 双重检测锁模式的懒汉式单例  DCL 懒汉式
    public static LazyMan getInstance() {
        if (lazyMan == null) {
            synchronized (LazyMan.class) {
                if (lazyMan == null) {
                    lazyMan = new LazyMan();// 不是一个原子性操作
                    /*
                    1、分配内存空间
                    2、执行构造方法，初始化对象
                    3、把这个对象指向这个空间

                    123
                    132 A
                        B // 此时B线程进来会认为lazyman不为null
                          // 直接返回 此时lazyman 还没有完成构造
                          // 为了避免指令重排
                       */
                }
            }
        }

        return lazyMan;
    }

    // 单线程下确实单例ok,但是多线程并发
    public static void main(String[] args) throws Exception {
        // 反射 可以破环这种单例
//        LazyMan instance = LazyMan.getInstance();
        Field qinjiang = LazyMan.class.getDeclaredField("qinjiang");
        qinjiang.setAccessible(true);


        Constructor<LazyMan> declaredConstructor =LazyMan.class.getDeclaredConstructor(null);
        declaredConstructor.setAccessible(true);//无视私有构造器
        LazyMan  instance=declaredConstructor.newInstance();

        qinjiang.set(instance,false);

        LazyMan  instance2=declaredConstructor.newInstance();

        System.out.println(instance);
        System.out.println(instance2);
    }
}
```

**静态内部类**

```
// 静态内部类实现单例模式 不安全
public class Holder {
    private Holder(){

    }

    public static Holder getInstance(){
        return InnerClass.HOLDER;
    }

    public static class InnerClass{
        private static final Holder HOLDER = new Holder();
    }
}
```

单例不安全，因为有反射

> **枚举**

```
// enum 本身也是一个 class 类
public enum  EnumSingle {

    INSTANCE;

    public EnumSingle getInstance(){
        return INSTANCE;
    }
}

class Test{
    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        EnumSingle instance1 = EnumSingle.INSTANCE;
        //Constructor<EnumSingle> declaredConstructor=EnumSingle.class.getDeclaredConstructor(null);
        // 枚举没有无参构造，只有有参构造
        Constructor<EnumSingle> declaredConstructor=EnumSingle.class.getDeclaredConstructor(String.class,int.class);
        declaredConstructor.setAccessible(true);
        EnumSingle instance2 = declaredConstructor.newInstance();

        // java.lang.NoSuchMethodException: com.kuang.single.EnumSingle.<init> 没有空参的构造方法
        // java.lang.IllegalArgumentException: Cannot reflectively create enum objects  反射不能破坏枚举的单例
        System.out.println(instance1);
        System.out.println(instance2);
    }
}
```

枚举没有无参构造，只有有参构造



## 工厂设计模式

作用：

- ==实现了创建者和调用者的分离==
- 详细分类：
  - 　　**简单工厂模式**：用来生产同一等级结构中的任意产品（对于增加新的产品，需要扩展已有代码）
  - 　　**工厂方法模式**：用来生产同一等级结构中的固定产品（支持增加任意产品）
  - 　　**抽象工厂模式**：围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。

工厂设计模式的原则（OOP七大原则）：

- 开闭原则：一个软件的实体应当对扩展开放，对修改关闭
- 依赖倒转原则：要针对接口编程，不要针对实现编程
- 迪米特法则：只与你直接的朋友通信，而避免和陌生人通信

核心本质：

- ==实例化对象不使用new，用工厂方法代替 factory==
- 将选择实现类，创建对象统一管理和控制。从而将调用者跟我们的实现类解耦

### 简单工厂模式（静态工厂模式）

用来生产同一等级结构中的任意产品（对于增加新的产品，需要扩展已有代码）

```
public interface Car {
    void name();
}

public class WuLing implements Car{

    @Override
    public void name() {
        System.out.println("五菱宏光");
    }
}

public class Tesla implements Car{

    @Override
    public void name() {
        System.out.println("特斯拉");
    }
}


// 静态工厂模式==简单工厂模式
//增加一个新的产品，如果你不修改代码，做不到！
// 不满足开闭原则
public class CarFactory {

    // 方法一： 不满足开闭原则 扩展的时候改变了原来的类
    public static Car getCar(String car){
        if(car.equals("wuling")){
            return new WuLing();
        }else if(car.equals("tesila")){
            return new Tesla();
        }else {
            return null;
        }
    }

    // 方法二： 这样子扩展的时候还是改变了原来的类
    public static Car geyWuling(){
        return new WuLing();
    }
    public static Car geyTesla(){
        return new Tesla();
    }


}


public class Consumer {
    public static void main(String[] args) {
        // 接口，所有的实现类
        // Car car = new WuLing();
        // Car car1 = new Tesla();

        // 2、使用工厂创建
        Car car = CarFactory.getCar("wuling");
        Car car1 = CarFactory.getCar("tesila");

        car.name();
        car1.name();
    }
}
```

弊端：

增加一个新的产品，做不到不修改代码。

> 思想结构图

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204281130680.png)

### 工厂方法模式：

用来生产同一等级结构中的固定产品（支持增加任意产品）

```
public interface Car {
    void name();
}

public class WuLing implements Car {

    @Override
    public void name() {
        System.out.println("五菱宏光");
    }
}

public class Tesla implements Car {

    @Override
    public void name() {
        System.out.println("特斯拉");
    }
}

// 工厂方法模式
public interface CarFactory {
    Car getCar();
}

public class WulingFactory implements CarFactory{
    @Override
    public Car getCar() {
        return new WuLing();
    }
}

public class TeslaFactory implements CarFactory{
    @Override
    public Car getCar() {
        return new Tesla();
    }
}

public class Consumer {
    public static void main(String[] args) {
        Car car = new WulingFactory().getCar();
        Car car1 = new TeslaFactory().getCar();

        car.name();
        car1.name();

       // Car car2 = new MoBaiFactory().getCar();  扩展的话 加上对应的车类和对应的工厂类即可 满足开闭原则
        car2.name();
    }
}
```

![img](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204281130922.png)


对比简单工厂模式

1、结构复杂度：simple>method

2、代码复杂度：==simple>method==

3、编程复杂度：simple>method

4、管理上的复杂度：simple>method

==根据设计原则，使用工厂方法模式；根据实际业务，使用简单工厂模式（`我们应当灵活运用设计模式，但是也不能被他束缚`）==

## 抽象工厂模式：

==围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂==

定义：

抽象工厂模式提供了一个==创建一系列相关或者相互依赖对象的接口，无需指定他们的具体的类（适用于针对整个产品族，产品等级数量相对固定的情况）==

适用场景：

- 客户端（应用层）不依赖于产品类实例如何被创建、实现等细节
- ==强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量的重复代码==
- 提供一个产品类的库，所有的产品以同样的接口出现，从而使得客户端不依赖于具体实现

![img](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204281130850.png)



```
// 手机产品接口
public interface IphoneProduct {

    void start();
    void shutdown();
    void callup();
    void sendSMS();
}

// 小米手机
public class XiaomiPhone implements IphoneProduct{
    @Override
    public void start() {
        System.out.println("开启小米手机");
    }

    @Override
    public void shutdown() {
        System.out.println("关闭小米手机");
    }

    @Override
    public void callup() {
        System.out.println("小米手机打电话");
    }

    @Override
    public void sendSMS() {
        System.out.println("小米手机发短信");
    }
}


// 华为手机
public class HuaweiPhone implements IphoneProduct{
    @Override
    public void start() {
        System.out.println("开启华为手机");
    }

    @Override
    public void shutdown() {
        System.out.println("关闭华为手机");
    }

    @Override
    public void callup() {
        System.out.println("华为手机打电话");
    }

    @Override
    public void sendSMS() {
        System.out.println("华为手机发短信");
    }
}

// 路由器产品接口
public interface IRouterProduct {

    void start();
    void shutdown();
    void openWifi();
    void setting();
}

// 小米路由器
public class XiaomiRouter implements IRouterProduct{
    @Override
    public void start() {
        System.out.println("启动小米路由器");
    }

    @Override
    public void shutdown() {
        System.out.println("关闭小米路由器");
    }

    @Override
    public void openWifi() {
        System.out.println("打开小米Wi-Fi");
    }

    @Override
    public void setting() {
        System.out.println("小米设置");
    }
}

// 华为路由器
public class HuaweiRouter implements IRouterProduct{
    @Override
    public void start() {
        System.out.println("启动华为路由器");
    }

    @Override
    public void shutdown() {
        System.out.println("关闭华为路由器");
    }

    @Override
    public void openWifi() {
        System.out.println("打开华为Wi-Fi");
    }

    @Override
    public void setting() {
        System.out.println("华为设置");
    }
}

// 抽象产品工厂
public interface IProductFactory {

    // 生产手机
    IphoneProduct iphoneProduct();

    // 生产路由器
    IRouterProduct irouterProduct();

}

public class XiaomiFactory implements IProductFactory{
    @Override
    public IphoneProduct iphoneProduct() {
        return new XiaomiPhone();
    }

    @Override
    public IRouterProduct irouterProduct() {
        return new XiaomiRouter();
    }
}

public class HuaweiFactory implements IProductFactory{
    @Override
    public IphoneProduct iphoneProduct() {
        return new HuaweiPhone();
    }

    @Override
    public IRouterProduct irouterProduct() {
        return new HuaweiRouter();
    }
}

public class Client {
    public static void main(String[] args) {
        System.out.println("小米系列产品--------------------");
        // 小米工厂
        XiaomiFactory xiaomiFactory = new XiaomiFactory();

        IphoneProduct iphoneProduct = xiaomiFactory.iphoneProduct();
        iphoneProduct.callup();
        iphoneProduct.sendSMS();

        IRouterProduct iRouterProduct = xiaomiFactory.irouterProduct();
        iRouterProduct.openWifi();

        System.out.println("华为系列产品--------------------");
        // 小米工厂
        HuaweiFactory huaweiFactory = new HuaweiFactory();

        iphoneProduct = huaweiFactory.iphoneProduct();
        iphoneProduct.callup();
        iphoneProduct.sendSMS();

        iRouterProduct = huaweiFactory.irouterProduct();
        iRouterProduct.openWifi();
    }
}
```

![img](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204281130714.png)



 ==多了一个抽象工厂，抽象工厂把每个工厂创建的产品已经声明，实现该工厂的工厂生产自己的产品，因此该模式适合创建一个产品簇。==

**优点**

具体产品在应用层的代码隔离，无需关心创建的细节

将一个系列的产品统一到一起创建（==指定的工厂中创建==）

**缺点：**

规定了所有可能被创建的产品集合，产品族中扩展新的产品困难；

增加了系统的抽象性和理解难度。

**工厂模式小结：** ==简单工厂模式：虽然某种程度上不符合设计原则，但实际使用最多==

工厂方法模式：不修改已有类的前提下，通过增加新的工厂类实现扩展

抽象工厂模式：==不可以增加产品（会违反开闭原则），可以增加产品族==



**应用场景：**

- jdk中calendar的getInstance方法
- JDBC中的Connection对象的获取
- Spring中的IOC容器创建管理bean对象
- 反射中Class对象的newInstance方法



## 建造者模式

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204281459213.png)

### 角色分析

![在这里插入图片描述](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204281459848.png)

![image-20220428160837397](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204281608721.png)



```
// 抽象的建造者：只是定义一些方法和接口
public abstract class Builder {
    abstract void buildA(); // 地基
    abstract void buildB(); // 钢筋工程
    abstract void buildC(); // 铺电线
    abstract void buildD(); // 粉刷

    // 完工：得到产品
    abstract Product getProduct();
}

// 产品：房子
public class Product {

    private String buildA;
    private String buildB;
    private String buildC;
    private String buildD;

    public String getBuildA() {
        return buildA;
    }

    public void setBuildA(String buildA) {
        this.buildA = buildA;
    }

    public String getBuildB() {
        return buildB;
    }

    public void setBuildB(String buildB) {
        this.buildB = buildB;
    }

    public String getBuildC() {
        return buildC;
    }

    public void setBuildC(String buildC) {
        this.buildC = buildC;
    }

    public String getBuildD() {
        return buildD;
    }

    public void setBuildD(String buildD) {
        this.buildD = buildD;
    }

    @Override
    public String toString() {
        return "Product{" +
                "buildA='" + buildA + '\'' +
                ", buildB='" + buildB + '\'' +
                ", buildC='" + buildC + '\'' +
                ", buildD='" + buildD + '\'' +
                '}';
    }
}

// 具体的建造者：工人
public class Worker extends Builder {

    private Product product;

    public Worker() {
         product = new Product();// 工人负责创建产品
    }

    @Override
    void buildA() {
        product.setBuildA("地基");
        System.out.println("地基");
    }

    @Override
    void buildB() {
        product.setBuildB("钢筋工程");
        System.out.println("钢筋工程");
    }

    @Override
    void buildC() {
        product.setBuildC("铺电线");
        System.out.println("铺电线");
    }

    @Override
    void buildD() {
        product.setBuildD("粉刷");
        System.out.println("粉刷");
    }

    @Override
    Product getProduct() {
        return product;
    }
}


// 指挥：核心 负责指挥构建一个工程，工程如何构建，由他决定
public class Director {

    // 指挥工人按照顺序建房子
    public Product build(Builder builder){
        //指挥者可以在这里面修改哪一步先实施
        builder.buildA();
        builder.buildB();
        builder.buildC();
        builder.buildD();
        return builder.getProduct();
    }
}



public class Test {
    public static void main(String[] args) {
        // 指挥
        Director director = new Director();
        // 指挥 具体的工人 完成产品
        Product build = director.build(new Worker());
        System.out.println(build.toString());
    }
}
```

> 输出：

![image-20220428150656537](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204281506779.png)

上面示例是Builder模式的常规用法，`Director在builder`模式中具有重要的作用，他用于指导具体构建者如何构建产品，**控制调用先后次序，并向调用者返回完整的产品类，**==但有些情况下需要简化系统结构，可以把Director和抽象建造者进行结合==

`使用时可以根据用户需求自由定义更改内容，并且无需改变具体的构造方式。就可以生产出不同复杂产品`

例如：麦当劳的套餐，服务员（具体建造者）可以随机搭配任意几种产品（零件）组成一款套餐（产品），然后出售给客户。比第一种方式少了指挥者，主要是因为第二种方式把指挥者交给用户来操作，使得产品创建更加简单灵活

```
// 抽象的建造者
public abstract class Builder {
    public abstract Builder builderA(String msg);// 汉堡
    public abstract Builder builderB(String msg);// 可乐
    public abstract Builder builderC(String msg);// 薯条
    public abstract Builder builderD(String msg);// 甜点

    abstract Product getProduct();
}

// 产品 ：套餐
public class Product {
    private String BuildA = "汉堡" ;
    private String BuildB = "可乐" ;
    private String BuildC = "薯条" ;
    private String BuildD = "甜点" ;

    public String getBuildA() {
        return BuildA;
    }

    public void setBuildA(String buildA) {
        BuildA = buildA;
    }

    public String getBuildB() {
        return BuildB;
    }

    public void setBuildB(String buildB) {
        BuildB = buildB;
    }

    public String getBuildC() {
        return BuildC;
    }

    public void setBuildC(String buildC) {
        BuildC = buildC;
    }

    public String getBuildD() {
        return BuildD;
    }

    public void setBuildD(String buildD) {
        BuildD = buildD;
    }

    @Override
    public String toString() {
        return "Product{" +
                "BuildA='" + BuildA + '\'' +
                ", BuildB='" + BuildB + '\'' +
                ", BuildC='" + BuildC + '\'' +
                ", BuildD='" + BuildD + '\'' +
                '}';
    }
}


// 具体的建造者
public class Woker extends Builder{

    private  Product product;

    public Woker() {
        product = new Product();
    }

    @Override
    public Builder builderA(String msg) {
        product.setBuildA(msg);
        return this;
    }

    @Override
    public Builder builderB(String msg) {
        product.setBuildB(msg);
        return this;
    }

    @Override
    public Builder builderC(String msg) {
        product.setBuildC(msg);
        return this;
    }

    @Override
    public Builder builderD(String msg) {
        product.setBuildD(msg);
        return this;
    }

    @Override
    Product getProduct() {
        return product;
    }
}



public class test1 {
    public static void main(String[] args) {
        // 服务员
        Woker woker = new Woker();
        // 链式编程  ：在原来的基础上，可以自由的自合，如果不组合也有固定的套餐
        Product product = woker.getProduct();
        System.out.println(product.toString());
    }
}



public class Test2 {

    public static void main(String[] args) {
        // 服务员
        Woker woker = new Woker();
        // 链式编程  ：在原来的基础上，可以自由的自合，如果不组合也有固定的套餐
        Product product = woker.builderA("全家桶").builderB("雪碧")
                .getProduct();
        System.out.println(product.toString());
    }
}
```

> 分别输出：

![image-20220428154807126](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204281548267.png)

![image-20220428154817694](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204281548770.png)

优点：

- ==产品的建造和表示分离，实现了解耦。使用建造者模式可以使客户端不必知道产品内部组成的细节==
- ==将复杂产品的创建步骤分解在不同的方法中，是得创建过程更加清晰==
- ==具体的建造者之间是相互独立的，这有利于系统的扩展。增加新的具体建造者无需修改原有类库代码，符合`“开闭原则”`==

缺点：

- 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似；如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制(==比如产品（套餐）都只包含四个单项，不然的话建造者模式没法用==)
- ==如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变的很庞大==



`建造者模式适合创建需要多个步骤组装的产品对象，而抽象工厂模式适合的是一系列相关的产品，这些产品构成一个产品族 。`

![image-20220428161028460](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204281610683.png)



## 原型模式

克隆=拷贝    ==以某种原型复制一个对象，提高复用性，提高程序效率==  

Prototype:原型

`Cloneable接口` `clone()方法`

[浅克隆和深克隆的区别](https://blog.csdn.net/baiye_xing/article/details/71788741)

> 浅克隆是指拷贝对象时仅仅拷贝对象本身（包括对象中的基本变量还有String），而不拷贝对象包含的引用指向的对象。
>
> 深克隆不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象。

### 代码实现

> Video

```java
package com.kwq.builder.prototype.demo01;

import java.util.Date;

/*
1..实现一个接口Cloneable
2.重写一个方法clone()
*/
//Video
public class Video implements Cloneable { //无良up 主，克隆别人的视频! .
    private String name;
    private Date createTime;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }

    public Video() {

    }

    public Video(String name, Date createTime) {
        this.name = name;
        this.createTime = createTime;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Date getCreateTime() {
        return createTime;
    }

    public void setCreateTime(Date createTime) {
        this.createTime = createTime;
    }

    @Override
    public String toString() {
        return "Video{" +
                "name='" + name + '\'' +
                ", createTime=" + createTime +
                '}';
    }
}

```



```
package com.kwq.builder.prototype.demo01;

import java.util.Date;

/*
客户端:克隆
*/
public class Bilibili {
    public static void main(String[] args) throws CloneNotSupportedException {
        //原型对象v1
        Date date = new Date();
        Video v1 = new Video("狂神说Java", date);
        Video v2 = (Video) v1.clone();
        System.out.println("v1=>" + v1);
        System.out.println("v2=>" + v2);
        System.out.println("v1=>hashcode:"+v1.hashCode());
        System.out.println("v2=>hashcode:"+v2.hashCode());
        System.out.println("==========================");
        date.setTime(2131231);
        v2.setName("kwq");
        System.out.println("v1=>" + v1);
        System.out.println("v2=>" + v2);
        System.out.println("v1=>hashcode:"+v1.hashCode());
        System.out.println("v2=>hashcode:"+v2.hashCode());
       /* //v1克隆v2
        //Video v2 = new Video( "狂神说Java", date);
       // Video v2 = (Video) v1.clone();

        System.out.println("v2=>hash:" + v2.hashCode());

        v2.setName("Clone:狂神说java");
        System.out.println("v1=>" + v1);
        System.out.println("v1=>hash:" + v1.hashCode());
        System.out.println("v2=>" + v2);
        System.out.println("v2=>hash:" + v2.hashCode());*/
    }
}

```

> 输出： 说明两个对象用的是同一个Date（地址一样） 而name是两个因为地址不一样 这就是浅拷贝

![image-20220428185156442](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204281851656.png)

> 浅拷贝图示

![image-20220428185319904](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204281853146.png)

==**浅拷贝存在的的问题：若我们将其中一个对象的Date内容改了，那么另外一个对象也会跟着改，因为用的是一块地址。但是我们不想要这种情况；**==

解决方案：`1.深拷贝：改造clone方法 2.序列化与反序列化（需要进行io操作，效率低）` 

> 深拷贝原理

![image-20210220165801768](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204281620218.png)

### 代码再实现

> Video

```
package com.kwq.builder.prototype.demo02;

import java.util.Date;

public class Video implements Cloneable { //无良up 主，克隆别人的视频! .
    private String name;
    private Date createTime;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        Object obj = super.clone();
        //实现深克隆~序列化， 反序列化
        Video v = (Video) obj;
        v.createTime = (Date) this.createTime.clone();//将这个对象的属性也进行克隆~
        return v;
    }

    public Video() {

    }

    public Video(String name, Date createTime) {
        this.name = name;
        this.createTime = createTime;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Date getCreateTime() {
        return createTime;
    }

    public void setCreateTime(Date createTime) {
        this.createTime = createTime;
    }

    @Override
    public String toString() {
        return "Video{" +
                "name='" + name + '\'' +
                ", createTime=" + createTime +
                '}';
    }
}

```

> Bilibili
>

```
package com.kwq.builder.prototype.demo02;

import java.util.Date;

/*
客户端:克隆
*/
public class Bilibili {
    public static void main(String[] alrgs) throws CloneNotSupportedException {
        //原型对象v1
        Date date = new Date();
        Video v1 = new Video("狂神说Java", date);
        //v1克隆v2
        //Video v2 = new Video( "狂神说Java", date);
        Video v2 = (Video) v1.clone();
        System.out.println("v1=>" + v1);
        System.out.println("v2=>" + v2);
        date.setTime(22131231);
        System.out.println("====================");
        System.out.println("v1=>" + v1);
        System.out.println("v2=>" + v2);
    }
}

```

> 运行结果

![image-20220428190559727](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204281905890.png)



## 适配器模式

![img](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204281931472.png)

 

结构性模式:

- 作用

  从程序的结构上实现松耦合, 从而可以扩大整体的类结构,用来解决更大的问题

适配器模式就像USB网线转换器

### 代码实现

> Adaptee
>

```
package com.kwq.adapter;

//要被适配的类:网线
public class Adaptee {
    public void request() {
        System.out.println("连接网线上网");
    }
}

```

> Adapter
>

```
package com.kwq.adapter;

//真正的适配器，需要连接USB,连接网线~
public class Adapter extends Adaptee implements NetToUsb {
    @Override
    public void handleRequest() {
        //上网的具体实现，找一个转接头
        super.request();
    }
}

```

NetToUsb

```
package com.kwq.adapter;

//按1口转换器的抽象实现~
public interface NetToUsb {
//作用:处理请求，网线=>usb
public void handleRequest();
}
```

Adapter2

```
package com.kwq.adapter;

//真正的适配器，需 要连接USB,连接网线~
public class Adapter2 implements NetToUsb {
    //组合模式
    private Adaptee adaptee;

    public Adapter2(Adaptee adaptee) {
        this.adaptee = adaptee;
    }
    @Override
    public void handleRequest() {
        //上网的具体实现，找一个转接头
        adaptee.request();//可以上网
    }
}

```

Computer

```
package com.kwq.adapter;

//客户端关: 想上:网，插不L:网线~
public class Computer {
    //我们的电脑需要连接:转换器才可以:网
    public void net(NetToUsb adapter) {
        //.上网的具体实现， 找个转换器
        adapter.handleRequest();
    }

    public static void main(String[] args) {
        //电脑，适配器，网线~
      /*  Computer computer = new Computer(); //电脑
        Adaptee adaptee = new Adaptee(); //网线
        Adapter adapter = new Adapter(); //转按器
        computer.net(adapter);*/

        Computer computer = new Computer(); //电脑
        Adaptee adaptee = new Adaptee(); //网线
        Adapter2 adapter = new Adapter2(adaptee); //转按器
        computer.net(adapter);



    }
}

```

> 运行结果

![image-20220428201709617](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204282017866.png)

角色分析

- ==将一个类的接口转换成客户希望的另外一个接口. Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作==

角色分析

- 目标接口: 客户所期待的接口, 目标可以是具体的或抽象的类, 可以是接口(`这里指的是USB`)
- 需要适配的类: 需要适配的类或适配者类(`这里指的是网线`)
- 适配器: 通过包装一个需要适配的对象, ==把原接口转换成目标对象==

> 原理理解
>


对象适配器优点（`对象适配器和适配者是has a的关系`）

- 一个对象适配器可以把多个不同的适配者适配到同一个目标
- 可以适配一个适配者的子类,由于适配器和适配者之间是关联关系,根据"里氏代换原则", 适配者的子类也可通过该适配器进行适配

类适配器缺点(`对象适配器继承适配者`)

- ==对于Java, C#等不支持多重类继承的语言, 一次最多只能适配一个适配者类,不能同时适配多个适配者,==
- ==在Java, C#等语言中, 类适配器模式中的目标抽象类只能为接口, 不能为类, 其使用有一定的局限性==

适用场景

- 系统需要使用一些现有的类, 而这些类的接口(如方法名)不符合系统的需求（`通过适配模式对这些类进行包装，从某种角度来讲也算是升级[系统升级]`）

- ==想创建一个可以重复使用的类, 用于与一些彼此之间没有太大关联的一些类,包括一些可能在将来引进的类一起工作==

  

## 桥接模式

- 桥接模式是==将抽象部分与它的实现部分分离, 使他们都可以独立地变化==, 它是一种对象结构型模式, 又称为柄体(Handle and Body)模式或接口(Interface)模式

​       `每个落地的实现都违反单一原则（干了两件事 1、什么牌子 2、台式）`

- ![image-20210221170558686](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204282040216.png)

- 分析:

  这个场景中有两个变化的维度: 品牌, 类型

   代码实现大脑所想

  ![image-20210221171656039](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204282040952.png)

### 代码实现

> Brand

```
package com.kwq.bridge;

//品牌
public interface Brand {

    void info();
}
```

> Lenovo

```
package com.kwq.bridge;

//联想品牌
public class Lenovo implements Brand {
    @Override
    public void info() {
        System.out.print("联想");
    }
}
```

> Apple

```
package com.kwq.bridge;
//苹果品牌
public class Apple implements Brand {
    @Override
    public void info() {
        System.out.print("苹果");
    }
}
```

> Computer

```
package com.kwq.bridge;

//抽象的电脑类型类
public abstract class Computer {
    //组合，品牌~
     protected Brand brand;  //protected 保证 子类可以被继承

    public Computer(Brand brand) {
        this.brand = brand;
    }

    public void info() {
        brand.info();//自带品牌
    }


}

class Desktop extends Computer {
    public Desktop(Brand brand) {
        super(brand);
    }

    @Override
    public void info() {
        super.info();
        System.out.print("台式机");
    }
}

class Laptop extends Computer {
    public Laptop(Brand brand) {
        super(brand);
    }

    @Override
    public void info() {
        super.info();
        System.out.print("笔记本");
    }
}
```

> Test

```
package com.kwq.bridge;

public class Test {
    public static void main(String[] args) {
        //苹果管记本
        Computer computer = new Laptop(new Apple());  //组装 笔记本和品牌进行组装
        computer.info();

        System.out.println();
        //联想台式机
        Computer computer2 = new Desktop(new Lenovo()); //组装 笔记本和品牌进行组装
        computer2.info();
    }
}
```

> 运行结果    

![image-20220428210208939](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204282102051.png)

> 结构逻辑图

![](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204282141965.png)

> 优劣势分析

好处分析:

- 桥接模式偶尔类似于多继承方案，但是多继承方案违背了类的单一职责原则，复用性比较差，类的个数也非常多，桥接模式是比多继承方案更好的解决方法。==极大的减少了子类的个数，从而降低管理和维护的成本==
- 桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。==符合开闭原则==，就像一座桥，可以把两个变化的维度连接起来!

劣势分析:

- ==桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程==。
- 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性.

最佳实践:

- ==如果一个系统需要在构建的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。==
- ==一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。==
- ==虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。==

场景:

- Java语言通过Java虚拟机实现了平台的无关性。
- JDBC驱动程序也是桥接模式的应用之一。

![image-20220428214120027](https://cdn.jsdelivr.net/gh/kkkkwqqqq/typora/typoraImage/202204282141251.png)

`A1 A2 A3代表java程序`   




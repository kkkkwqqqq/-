# 多线程

## 与多线程相关的几个概念

**1.多任务**

![image-20220128145608659](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220128145608659.png)

==现实中太多这样同时做多件事情的例子了，看起来是多个任务都在做，其实本质上我们的大脑在同一时间依旧只做了一件事情。==

**2.多线程**

![image-20220128145759400](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220128145759400.png)

==原来是一条路，慢慢因为车太多了，道路阻塞，效率极低。为了提高使用的效率，能够充分利用道路，于是加了多个车道。从此，妈妈再也不用担心道路阻塞了。==

![image-20220128145854422](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220128145854422.png)

**3.程序.进程.线程**

![image-20220128145949362](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220128145949362.png)

**4.Process与Thread**

- 说起==进程==,就不得不说下程序。程序是指令和数据的有序集合，其本身==没有任何运行的含义，是一个静态的概念。==
- ==而进程则是执行程序的依次执行过程，它是一个动态的概念。是系统资源分配的单位。==
- 通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。`==线程是CPU调度和执行的单位`。==

> 注意：
>  很多多线程是模拟出来的，真正的多线程是指有==多个cpu，即多核，如服务器==。==如果是模拟出来的多线程，即在一个cpu的情况下，在同一个时间点，cpu只能执行一个代码，因为切换的很快，所以就有同时执行的错局。==

**5.核心概念**

- 线程就是独立的执行路径
- 在程序运行时,即使没有自己创建线程,后台也会有多个线程,比如主线程,GC线程
- main()称之为主线程,为系统的入口,用于执行整个程序
- ==在一个进程中,如果开辟了多个线程,线程的运行是由调度器（cpu）安排调度的,调度器是与操作系统紧密相关的,先后顺序是不能人为干预的==
- 对同一份资源操作时会存在资源抢夺的问题,需要加入并发控制
- 线程会带来额外的开销,如CPU调度时间,并发控制开销
- ==每个线程在自己的工作内存交互,`内存控制不当`会造成数据不一致==`并发造成数据的不一致的原因`

> 总结：大致就是，比如我们写了一段程序，运行起来就是一个进程，这个进程中有主线程和gcc线程同时执行！！！



## 线程创建的三种方式

### 1继承[Thread类](https://so.csdn.net/so/search?q=Thread类&spm=1001.2101.3001.7020)(重要)

- 自定义线程类继承`Thread`类
- 重写`run()`方法，编写线程执行体
- 创建线程对象，调用`start()`方法启动线程

```
package com.kwq.demo1;
//创建线程方式一：继承Thread类，重写run方法，调用start开启线程
public class TestThread1 extends Thread {
    @Override
    public void run() {
        //run方法线程体
        for (int i = 0; i < 20; i++) {
            System.out.println("我在看代码----" + i);
        }
    }

    public static void main(String[] args) {
        //main线程，主线程
        //创建一个线程对象
     TestThread1 testThread1 = new TestThread1();
        //调用start（）开启线程
        testThread1.start();
        for (int i = 0; i < 2000; i++) {
            System.out.println("我在学习多线程----" + i);
        }
    }


}
```

> 结果表示：交替执行，说明线程并行

![image-20220128153334962](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220128153334962.png)

> 总结:注意，==线程开启不一定立即执行，由CPU调度执行==

#### 多线程案例

> 导入依赖

```java
<dependency>
    <groupId>commons-io</groupId>
    <artifactId>commons-io</artifactId>
    <version>2.11.0</version>
</dependency>
```

> 具体代码

```java
package com.kwq.demo1;

import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.net.URL;

//练习Thread，实现多线程同步下载图片
public class TestThread2 extends Thread {
    private String url;//网络图片地址
    private String name;//网络图片文件名

    //有参构造
    public TestThread2(String url, String name) {
        this.url = url;
        this.name = name;
    }

    //下载图片线程的执行体
    @Override
    public void run() {
        WebDownloader webDownloader = new WebDownloader();
        webDownloader.downloader(url, name);
        System.out.println("下载了文件名为:" + name);
    }

    public static void main(String[] args) {


        TestThread2 t1= new TestThread2("https://img-home.csdnimg.cn/images/20201124032511.png", "1.png");
        TestThread2 t2 = new TestThread2("https://img-home.csdnimg.cn/images/20201124032511.png", "2.png");
        TestThread2 t3 = new TestThread2("https://img-home.csdnimg.cn/images/20201124032511.png", "3.png");
        t1.start();
        t2.start();
        t3.start();
}
 }



//下载器
class WebDownloader{
    //下载方法
    public void downloader(String url,String name){
        try {
            FileUtils.copyURLToFile(new URL(url),new File(name));
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println("IO异常，downloader方法出现问题");
        }
    }
}
```

> 输出结果：

![image-20220201113606832](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220201113606832.png)

![image-20220201113624003](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220201113624003.png)

#### 小结：

==不建议使用继承Thread类的方法创建线程类：避免OOP单继承的局限性==

### 2.实现Runnable接口

> jdk文档说明：

![image-20220201115440894](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220201115440894.png)

> 步骤：

- 自定义线程类实现`Runnable`接口
- 实现`run()`方法,编写线程执行体
- 创建线程对象,调用`start()`方法启动对象

> 具体代码演示：

```java
package com.kwq.demo1;

public class TestThread3 implements Runnable {
    @Override
    public void run() {
        //run方法线程体
        for (int i = 0; i < 20; i++) {
            System.out.println("我在看代码----" + i);
        }
    }

    public static void main(String[] args) {
        //创建runnable接口的实现类对象
        TestThread3 testThread = new TestThread3();
        //创建线程对象,通过线程对象来开启我们的线程,代理
        Thread thread = new Thread(testThread);
        //调用start（）开启线程
        thread.start();

        //new Thread(testThread).start();
        for (int i = 0; i < 2000; i++) {
            System.out.println("我在学习多线程----" + i);
        }
    }
}
```

> 输出

![image-20220201115054894](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220201115054894.png)

>  多线程案例代码

代码如下：

```java
package com.kwq.demo1;

import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.net.URL;

//练习Thread，实现多线程同步下载图片
public class TestThread2 implements Runnable {
    private String url;//网络图片地址
    private String name;//报错扥文件名

    //有参构造
    public TestThread2(String url, String name) {
        this.url = url;
        this.name = name;
    }

    //下载图片线程的执行体
    @Override
    public void run() {
        WebDownloader webDownloader = new WebDownloader();
        webDownloader.downloader(url, name);
        System.out.println("下载了文件名为:" + name);
    }

    public static void main(String[] args) {


        TestThread2 t1= new TestThread2("https://img-home.csdnimg.cn/images/20201124032511.png", "1.png");
        TestThread2 t2 = new TestThread2("https://img-home.csdnimg.cn/images/20201124032511.png", "2.png");
        TestThread2 t3 = new TestThread2("https://img-home.csdnimg.cn/images/20201124032511.png", "3.png");
        new Thread(t1).start();
        new Thread(t2).start();
        new Thread(t3).start();
}
 }



//下载器
class WebDownloader{
    //下载方法
    public void downloader(String url,String name){
        try {
            FileUtils.copyURLToFile(new URL(url),new File(name));
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println("IO异常，downloader方法出现问题");
        }
    }
}
```

> 输出

![image-20220201115900610](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220201115900610.png)

#### 小结：

==推荐使用实现Runnable接口的方法：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用==



**模拟并发之买票**

> 测试代码：

```
package com.kwq.demo1;

//多个线程同时操作同一个对象
//买火车票的例子
public class TestThread4 implements Runnable {
    //票数
    private int ticketNums = 10;

    @Override
    public void run() {
        while (true) {
            if (ticketNums <= 0) {
                break;
            }
            //模拟延时
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "--->拿到了第" + ticketNums-- + "张票");
        }
    }

    public static void main(String[] args) {
        TestThread4 ticket = new TestThread4();
        new Thread(ticket, "小红").start();
        new Thread(ticket, "老师").start();
        new Thread(ticket, "黄牛1").start();
        new Thread(ticket, "黄牛2").start();
    }
}
```

> 输出：

![image-20220201134256085](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220201134256085.png)

从输出结果可以看出很多问题！！！

**模拟并发之龟兔赛跑**

```java
package com.kwq.demo1;
//模拟龟兔赛跑
public class Race implements Runnable {
    //胜利者
    private static String winner;

    @Override
    public void run() {
        for (int i = 0; i <= 100; i++) {
            //模拟兔子休息
            if (Thread.currentThread().getName().equals("兔子") && i % 10 == 0) {
                try {
                    Thread.sleep(2);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            //判断比赛是否结束
            boolean flag = gameOver(i);
            //如果比赛结束,停止程序
            if (flag) {
                break;
            }
            System.out.println(Thread.currentThread().getName() + "--->跑了" + i + "步");
        }
    }

    //判断是否完成
    private boolean gameOver(int steps) {
        if (winner != null) {
            return true;
        } else {
            if (steps >= 100) {
                winner = Thread.currentThread().getName();
                System.out.println("winner is " + winner);
                return true;
            }
        }
        return false;
    }

    public static void main(String[] args) {
        Race race = new Race ();
        new Thread(race, "兔子").start();
        new Thread(race, "乌龟").start();
    }
}
```

> 输出发现基本都是乌龟赢

![image-20220201140535406](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220201140535406.png)

### 3.实现Callable接口(了解即可)

> 步骤：

1. 实现Callable接口，需要`返回值类型`
2. 重写call方法，需要抛出异常
3. 创建目标对象
4. 创建执行服务：ExecutorService ser = Executors.newFixedThreadPool(1);
5. 提交执行：Future result1 = ser.submit(11);
6. 获取结果：boolean r1 = result1.get()
7. 关闭服务：ser.shutdownNow();

> 演示：利用callable改造下载图片案例

```java
package com.kwq.demo02;
import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.util.concurrent.*;

//线程创建方式三：实现callable接口
public class TestCallable implements Callable<Boolean> {
    private String url;//网络图片地址
    private String name;//保存的文件名

    //有参构造
    public TestCallable(String url, String name) {
        this.url = url;
        this.name = name;
    }

    //下载图片线程的执行体
    @Override
    public Boolean call() throws Exception {
        WebDownloader1 webDownloader = new WebDownloader1();
        webDownloader.downloader(url, name);
        System.out.println("下载了文件名为:" + name);
        return true;
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        TestCallable t1 = new TestCallable("https://img-home.csdnimg.cn/images/20201124032511.png", "1.png");
        TestCallable t2 = new TestCallable("https://img-home.csdnimg.cn/images/20201124032511.png", "2.png");
        TestCallable t3 = new TestCallable("https://img-home.csdnimg.cn/images/20201124032511.png", "3.png");
        //创建执行服务
        ExecutorService ser = Executors.newFixedThreadPool(3);
        //提交执行
        Future<Boolean> r1 = ser.submit(t1);
        Future<Boolean> r2 = ser.submit(t2);
        Future<Boolean> r3 = ser.submit(t3);
        //获取结果
        boolean res1 = r1.get();
        boolean res2 = r2.get();
        boolean res3 = r3.get();
        System.out.println(res1);
        System.out.println(res2);
        System.out.println(res3);
        //关闭服务
        ser.shutdownNow();
    }
}

//下载器
class WebDownloader1{
    //下载方法
    public void downloader(String url,String name){
        try {
            FileUtils.copyURLToFile(new URL(url),new File(name));
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println("IO异常，downloader方法出现问题");
        }
    }
}
```

> 输出：

![image-20220201142332746](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220201142332746.png)

#### 好处

==可以定义返回值==

==可以抛出异常==



## Lamda表达式

> 介绍

![image-20220201144643413](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220201144643413.png)

> 为什么使用lambda表达式

- 避免匿名内部类定义过多
- ==其实质属于函数式编程的概念==
- 去掉了一堆没有意义的代码,只留下核心逻辑



理解Functional Interface (函数式接口) 是学习Java8 lamda表达式的关键。

> 函数式接口的定义:

任何接口,如果只包含`唯一一个抽象方法,`那么它就是一个`函数式接口`.

```java
public interface Runnable{
    public abstract void run();
}
```

`对于函数式接口,我们可以通过Lamda表达式来创建该接口的对象.`

### 演示推导Lambda表达式

> 正常方式：

```
package com.kwq.lanbda;
/*
推导lambda表达式
*/
public class TestLambda1 {
    public static void main(String[] args) {
        ILike like = new Like();
        like.lamda();
    }
}

// 1.定义一个函数式接口
interface ILike {
    void lamda();
}

// 2.实现类
class Like implements ILike {
    @Override
    public void lamda() {
        System.out.println("I like lamda");
    }
}
```

> 输出：

![image-20220201171632637](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220201171632637.png)

> 匿名内部类

```java
package com.kwq.lanbda;
/*
推导lambda表达式
*/
public class TestLambda1 {
    // 3.静态内部类
   static class Like2 implements ILike {
        @Override
        public void lamda() {
            System.out.println("I like lamda2");
        }
    }
    public static void main(String[] args) {
        ILike like = new Like2();
        like.lamda();
    }
}

// 1.定义一个函数式接口
interface ILike {
    void lamda();
}

```

> 输出

![image-20220201171915788](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220201171915788.png)

> 局部内部类

```java
package com.kwq.lanbda;
/*
推导lambda表达式
*/
public class TestLambda1 {
    public static void main(String[] args) {
        ILike like = null;
        //4.局部内部类
        class Like13 implements ILike {
            @Override
            public void lamda() {
                System.out.println("I like lamda3");
            }
        }
        like = new Like13();
        like.lamda();
    }
}

// 1.定义一个函数式接口
interface ILike {
    void lamda();
}

```

> 输出

![image-20220201172135063](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220201172135063.png)

> 匿名内部类

```java
package com.kwq.lanbda;
/*
推导lambda表达式
*/
public class TestLambda1 {
    public static void main(String[] args) {
        ILike like = null;
        //5.匿名内部类,没有类的名称,必须借助接口或者父类
         like = new ILike () {
            @Override
            public void lamda() {
                System.out.println("I like lamda4");
            }
        };
        like.lamda();
    }
}

// 1.定义一个函数式接口
interface ILike {
    void lamda();
}
```

> 输出：

![image-20220201172320806](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220201172320806.png)

> 就这样一步步推导就到了我们的lamda表达式

```java
package com.kwq.lanbda;
/*
推导lambda表达式
*/
public class TestLambda1 {
   static class Like2 implements ILike {
        //用lambda简化  jdk8及其以后才有的
        like=()->{
            System.out.println("i like lambda5");
        };
        like.lamda();
    }

    }
// 1.定义一个函数式接口
interface ILike {
    void lamda();
}

```

> 输出：

![image-20220201172603799](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220201172603799.png)

### lambda的不同表现形式

```java
package com.kwq.lanbda;

public class TestLambda2 {

    public static void main(String[] args) {
        //lamda表示简化
        ILove love = (int a) -> {
            System.out.println("I love you -->" + a);
        };
        love.love(520);
        //简化1 参数类型
        love = (a) -> {
            System.out.println("I love you -->" + a);
        };
         love.love(520);
        //简化2 简化括号
        love = a -> {
            System.out.println("I love you -->" + a);
        };
         love.love(520);
        // 简化3 去掉花括号
        love = a -> System.out.println("I love you -->" + a);
		 love.love(520);
    }
}

interface ILove {
    void love(int a);
}
```

> 总结：

1. lambda表达式只能有一行代码的情况下才能去掉花括号，如果存在多行，那么就用代码块包裹
2. 要使用lambda前提是接口为`函数式接口`
3. 多个参数也可以去掉参数类型，要去就都去掉，但是必须要加上括号

> 演示下总结3

```
package com.kwq.lanbda;

public class TestLambda2 {

    public static void main(String[] args) {
     ILove   love = (a,b) -> {
            System.out.println("I love you -->" + a);
         System.out.println(b);
        };
        love.love(520,1.0);
    }
}

interface ILove {
    void love(int a,double b);
}
```

> 输出：

![image-20220201174420907](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220201174420907.png)

## 静态代理和多线程的联系

> 静态代理代码：

```
package com.kwq.StaticProxy;

public class StaticProxy {
    public static void main(String[] args) {
        WeddingCompany weddingCompany = new WeddingCompany(new You());
        weddingCompany.happyMarry();
    }
}

//结婚
interface Marry {
    void happyMarry();
}

//真实角色:你去结婚
class You implements Marry {
    @Override
    public void happyMarry() {
        System.out.println("Bean要结婚了,超开心");
    }
}

//代理角色:帮助你结婚
class WeddingCompany implements Marry {
    private Marry target;//代理谁--》真实目标角色

    public WeddingCompany(Marry target) {
        this.target = target;
    }

    @Override
    public void happyMarry() {
        before();
        this.target.happyMarry();//这就是真实对象
        after();
    }

    private void after() {
        System.out.println("结婚之后,收尾款");
    }

    private void before() {
        System.out.println("结婚之前,布置现场");
    }
}
```

> 输出：

![image-20220201175844961](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220201175844961.png)

> 静态代理模式总结：

- 真实对象和代理对象都要实现同一个接口
- 代理角色要代理真实角色

> 静态代理好处：

代理对象可以做很多真实对象做不了的事情

真实对象专注做自己的事情

> 静态代理和线程的联系：

```java
public class StaticProxy {
    public static void main(String[] args) {
        new Thread(()->System.out.println("我爱你")).start();
        WeddingCompany weddingCompany = new WeddingCompany(new You());
        weddingCompany.happyMarry();
    }
}
```

> 说明：

==()->System.out.println("我爱你")是一个lambda表达式，等价于是一个Runable接口的实现类，Thread类相当于一个代理类，里面逻辑和weddingCompany类类似==



## 线程的状态

> 线程的五大状态：

![image-20220201210209596](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220201210209596.png)

![image-20220201210252307](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220201210252307.png)

> 线程的方法：

![image-20220201210321729](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220201210321729.png)

### 停止线程

![image-20220201210733847](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220201210733847.png)

> 为什么不推荐JDK提供的stop(),destroy()呢？

查看下源码就知道了，下图jdk直接表明了这是过时的方法，不推荐使用的!

![image-20220201210930599](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220201210930599.png)



> 具体代码

```java
package com.kwq.state;
/**
 * 测试stop
 * 1.建议线程正常停止-->利用次数,不建议死循环
 * 2.建议使用标志位-->设置一个标志位
 * 3.不要使用stop或者destroy等过时或者JDK不建议使用的方法
 */
public class TestStop implements Runnable {
    // 1. 设置一个标志位
    private boolean flag = true;

    @Override
    public void run() {
        int i = 0;
        while (flag) {
            System.out.println("run...Thread" + i++);
        }
    }

    // 2. 设置一个公开的方法停止线程,转换标志位
    public void stop() {
        this.flag = false;
    }

    public static void main(String[] args) {
        TestStop stop = new TestStop();
        new Thread(stop).start();
        for (int i = 0; i < 1000; i++) {
            System.out.println("main..." + i);
            if (i == 900) {
                //调用stop()切换标志位,让线程终止
                stop.stop();
                System.out.println("该线程停止了");
            }
        }
    }
}
```

> 输出：

![image-20220201211509520](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220201211509520.png)



### 线程休眠

![image-20220201213215284](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220201213215284.png)

#### 案例：

> 1.模拟网络延时：放大问题的发生性

```java
package com.kwq.state;
//模拟网络延时：放大问题的发送性
public class TestSleep implements Runnable {
    //票数
    private int ticketNums = 10;

    @Override
    public void run() {
        while (true) {
            if (ticketNums <= 0) {
                break;
            }
            //模拟延时
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "--->拿到了第" + ticketNums-- + "张票");
        }
    }

    public static void main(String[] args) {
        TestSleep ticket = new TestSleep();
        new Thread(ticket, "小红").start();
        new Thread(ticket, "老师").start();
        new Thread(ticket, "黄牛1").start();
    }
}
```

> 输出：

![image-20220202000007145](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220202000007145.png)

> 2.模拟倒计时

```java
package com.kwq.state;

public class TestSleep2 {
    public static void main(String[] args) {
        try {
            tenDown();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    //模拟倒计时
    public static void tenDown() throws InterruptedException {
        int num = 10;//10秒
        while (true) {
            Thread.sleep(1000);
            System.out.println(num--);
            if (num <= 0) {
                break;
            }
        }
    }
}
```

> 输出：

![image-20220202000718897](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220202000718897.png)

![image-20220202000733390](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220202000733390.png)

> 3.每一秒获取当前时间

```java
package com.kwq.state;

import java.text.SimpleDateFormat;
import java.util.Date;

public class TestSleep3 {
    public static void main(String[] args) {
        //获取系统当前时间
        Date startTime = new Date(System.currentTimeMillis());
        while (true) {
            try {
                Thread.sleep(1000);
                //更新系统时间
                System.out.println(new SimpleDateFormat("HH:mm:ss").format(startTime));
                startTime = new Date(System.currentTimeMillis());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

> 输出：

![image-20220202000824777](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220202000824777.png)

![image-20220202000834785](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220202000834785.png)



### 线程礼让

- 礼让线程，让当前正在执行的线程暂停，但不阻塞
- 将线程从==运行状态转为就绪状态==
- **让CPU重新调度，礼让不一定成功，看CPU心情**



> 示例代码

```java
package com.kwq.state;

public class TestYield {
    public static void main(String[] args) {
        MyYeild myYeild = new MyYeild();
        new Thread(myYeild, "a").start();
        new Thread(myYeild, "b").start();
    }
}

class MyYeild implements Runnable {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + "线程开始执行");
        Thread.yield();//礼让
        System.out.println(Thread.currentThread().getName() + "线程停止执行");
    }
}
```

> 输出有两种情况：

情况一：

![image-20220202001952062](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220202001952062.png)

情况二：

![image-20220202002005589](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220202002005589.png)



### 线程插队：

- join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞
- 可以想象成插队



> 示例代码：

```java
package com.kwq.state;

public class TestJoin implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i < 1000; i++) {
            System.out.println("线程vip来了"+i);
        }
    }

    public static void main(String[] args) throws InterruptedException {
        //启动我们的线程
        TestJoin testJoin = new TestJoin();
        Thread thread = new Thread(testJoin);
        thread.start();

        //主线程
        for (int i = 0; i < 500; i++) {
            if(i==200){
                thread.join();//插队
            }
            System.out.println("main"+i);
        }
    }
}
```

> 输出：

![image-20220202003539444](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220202003539444.png)



### 线程状态观测：

> 查看JDK帮助文档：

![image-20220202004519713](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220202004519713.png)

> 具体实现代码

```java
package com.kwq.state;

public class TestState {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("//");
        });
        //观察状态
        Thread.State state = thread.getState();
        System.out.println(state);//NEW
        //观察启动后
        thread.start();
        state = thread.getState();
        System.out.println(state);//Run
        while (state != Thread.State.TERMINATED) {//只要现成不终止,就一直输出状态
            Thread.sleep(10);
            state = thread.getState();//更新线程状态
            System.out.println(state);
        }
        //死亡后的线程不能再启动了,启动会报异常
        thread.start();
    }

}
```

> 输出：

![image-20220202011014851](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220202011014851.png)



## 线程的优先级：

![image-20220202012613441](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220202012613441.png)



> 测试代码

```java
package com.kwq.state;

public class TestPriority {
    public static void main(String[] args) {
        //主线程默认优先级
        System.out.println(Thread.currentThread().getName()+"-->"+Thread.currentThread().getPriority());

        MyPriority myPriority = new MyPriority();
        Thread thread1 = new Thread(myPriority);
        Thread thread2 = new Thread(myPriority);
        Thread thread3 = new Thread(myPriority);
        Thread thread4 = new Thread(myPriority);
        Thread thread5 = new Thread(myPriority);
        Thread thread6 = new Thread(myPriority);

        //先设置优先级,再启动
        thread1.start();

        thread2.setPriority(1);
        thread2.start();


        thread6.setPriority(11);
        thread6.start();
        
        thread3.setPriority(4);
        thread3.start();

        thread4.setPriority(Thread.MAX_PRIORITY);//MAX_PRIORITY=10
        thread4.start();

        thread5.setPriority(-1);
        thread5.start();


    }
}
class MyPriority implements Runnable{
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+"-->"+Thread.currentThread().getPriority());
    }
}
```

> 输出：

![image-20220202013100114](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220202013100114.png)



> 修改代码：

```java
package com.kwq.state;

public class TestPriority {
    public static void main(String[] args) {
        //主线程默认优先级
        System.out.println(Thread.currentThread().getName()+"-->"+Thread.currentThread().getPriority());

        MyPriority myPriority = new MyPriority();
        Thread thread1 = new Thread(myPriority);
        Thread thread2 = new Thread(myPriority);
        Thread thread3 = new Thread(myPriority);
        Thread thread4 = new Thread(myPriority);
        Thread thread5 = new Thread(myPriority);

        //先设置优先级,再启动
        thread1.start();

        thread2.setPriority(1);
        thread2.start();


        thread3.setPriority(4);
        thread3.start();

        thread4.setPriority(Thread.MAX_PRIORITY);//MAX_PRIORITY=10
        thread4.start();

        thread5.setPriority(8);
        thread5.start();


    }
}
class MyPriority implements Runnable{
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+"-->"+Thread.currentThread().getPriority());
    }
}
```

> 输出：

![image-20220202013154615](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220202013154615.png)



## 进程的分类

- 进程分为==用户进程和守护线程==
- 虚拟机==必须确保用户线程执行完毕==
- 虚拟机==不用等待守护线程执行完毕==
- 守护线程有哪些？如，后台记录操作日志，监控日志，垃圾回收等待等

`main方法就是用户线程，gcc是守护线程` 

> 示例代码：

```java

package com.kwq.state;
//测试守护线程
//上帝守护你
public class TestDemo {
    public static void main(String[] args) {
        God god = new God();
        You you = new You();

        Thread thread = new Thread(god);
        //默认false表示是用户线程,正常的线程都是用户线程...
        thread.setDaemon(true);
        //上帝守护线程启动
        thread.start();
        //你 用户线程启动
        new Thread(you).start();
    }
}

//上帝
class God implements Runnable{
    @Override
    public void run() {
        while (true){
            System.out.println("上帝保佑着你");
        }
    }
}

//你
class You implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i < 36500; i++) {
            System.out.println("你一生都开心的活着");
        }
        System.out.println("====goodbye!world====");
    }
}
```

> 输出：

![image-20220202015126823](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220202015126823.png)



## 线程同步机制

**多个线程操作同一个资源**

> 并发：==同一个对象==被==多个线程==同时操作

![image-20220202020620879](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220202020620879.png)

![image-20220202021053158](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220202021053158.png)

==线程同步要保证安全性需要两个条件：==`队列+锁`

> 线程同步：

由于同一进程的多个线程共享同一块存储空间，在带来方便的同时,也带来了==访问冲突==问题，为了保证数据在方法中被访问时的正确性，在访问时加入`锁机制synchronized`，当一个线程获得对象的排它锁，独占资源，其他线程必须等待，
使用后释放锁即可 

==存在以下问题：==

1. 一个线程持有锁会导致其他所有需要此锁的线程挂起；
2. 在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时,引起性能问题；
3. 如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置,引起性能问题．经典例子：排队大便和小便，要上小便的人排在要上大便人的后面！

### 三大不安全案例

> 案例一：买票

```java
package com.kwq.syn;
//不安全的买票
//可能有0也可能有负数
public class UnsafeBuyTicket {
    public static void main(String[] args) {
        BuyTicket buyTicket = new BuyTicket();
        new Thread(buyTicket, "苦逼的我").start();
        new Thread(buyTicket, "牛逼的我们").start();
        new Thread(buyTicket, "可恶的黄牛党").start();
    }
}

class BuyTicket implements Runnable {
    //票
    private int ticketNums = 10;
    boolean flag = true;

    @Override
    public void run() {
        //买票
        while (flag) {
            try {
                buy();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    //买票
    private void buy() {
        //判断是否有票
        if (ticketNums <= 0) {
            flag = false;//外部停止方式
            return;
        }
        //模拟延时，放大问题的发生性
        try {
            Thread.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //买票
        System.out.println(Thread.currentThread().getName() + "拿到" + ticketNums--);
    }

}
```

> 输出：

![image-20220202022533351](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220202022533351.png)



> 案例2：银行转账

```java
package com.kwq.syn;
//不安全的取钱
//两个人去银行取钱，账户
public class UnsafeBank {
    public static void main(String[] args) {
        Account account = new Account(100, "结婚基金");
        Drawing you = new Drawing(account, 50, "你");
        Drawing girlfriend = new Drawing(account, 100, "girlFriend");
        you.start();
        girlfriend.start();
    }
}

//账户
class Account {
    int money;//余额
    String cardName;//卡名

    public Account(int money, String cardName) {
        this.money = money;
        this.cardName = cardName;
    }
}

//银行:模拟取款
class Drawing extends Thread {
    Account account;//账户
    int drawingMoney;//取金额
    int nowMoney;//你手里的钱

    public Drawing(Account account, int drawingMoney, String name) {
        //调用父类的方法
        super(name);
        this.account = account;
        this.drawingMoney = drawingMoney;

    }

    //取钱
    @Override
    public void run() {
        //判断是否有钱
        if (account.money - drawingMoney < 0) {
            System.out.println(Thread.currentThread().getName() + "余额不足,不能进行取钱");
            return;
        }
        try {
            Thread.sleep(1000);//放大问题的发生性
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //卡内金额 = 余额-你的钱
        account.money = account.money - drawingMoney;
        //你手里的钱
        nowMoney = nowMoney + drawingMoney;
        System.out.println(account.cardName + "余额为:" + account.money);
        //this.getName()==super.getName()==Thread.currentThread().getName()
        System.out.println(super.getName() + "手里的钱:" + nowMoney);
    }

}
```

> 输出：

![image-20220202140304970](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220202140304970.png)

> 案例3：线程不安全的集合

```java
package com.kwq.syn;

import java.util.ArrayList;
import java.util.List;

//线程不安全的集合
public class UnsafeList {
    public static void main(String[] args) {
        List<String> list = new ArrayList<String>();
        for (int i = 0; i < 1000; i++) {
            new Thread(()->{
                list.add(Thread.currentThread().getName());  
            }).start();
        }
        System.out.println(list.size());
    }
}
```

> 输出：理应输出1000，可是却输出了998

![image-20220202141115009](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220202141115009.png)

==原因是两个线程同一瞬间同时操作了一个位置==



## 同步方法及代码块

> 同步方法：

由于我们可以通过private关键字来保证数据对象只能被方法(set/get方法)访问，所以我们只需要针对方法提出一套机制，这套机制就是 `synchronized` 关键字，它包括两种用法：`synchronized方法`和`synchronized块`.

==同步方法：public synchronized void method(int args) {}==

synchronized方法控制对`“对象”`的访问，`每个对象对应一把锁`，==每个
synchronized方法都必须获得调用该方法的对象(也就是类本身)的锁才能执行，否则线程会阻塞，
方法一旦执行 , 就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获
得这个锁，继续执行==

缺陷：若将一个大的方法申明为synchronized 将会影响效率

> 案例：解决买票不安全的问题

```java
package com.kwq.syn;
//不安全的买票
public class UnsafeBuyTicket {
    public static void main(String[] args) {
        BuyTicket buyTicket = new BuyTicket();
        new Thread(buyTicket, "苦逼的我").start();
        new Thread(buyTicket, "牛逼的我们").start();
        new Thread(buyTicket, "可恶的黄牛党").start();
    }
}

class BuyTicket implements Runnable {
    //票
    private int ticketNums = 10;
    boolean flag = true;

    @Override
    public void run() {
        //买票
        while (flag) {
            try {
                buy();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    //买票 synchronized同步方法 锁的是this
    private synchronized void buy() {
        //判断是否有票
        if (ticketNums <= 0) {
            flag = false;//外部停止方式
            return;
        }
        //模拟延时，放大问题的发生性
        try {
            Thread.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        //买票
        System.out.println(Thread.currentThread().getName() + "拿到" + ticketNums--);
    }

}
```

> 同步块：

同步块：synchronized ==(Obj ) { }==

Obj 称之为**同步监视器**

- Obj 可以是任何对象，但是推荐==使用共享资源作为同步监视器==
- 同步方法中无需指定同步监视器，因为同步方法的==同步监视器就是this，就是这个对象本身==

==同步监视器的执行过程==：

1. 第一个线程访问，锁定同步监视器，执行其中代码 .
2. 第二个线程访问，发现同步监视器被锁定，无法访问．
3. 第一个线程访问完毕，解锁同步监视器 .
4. 第二个线程访问,发现同步监视器没有锁,然后锁定并访问

> 案例一：解决银行取钱的问题

```java
package com.kwq.syn;
//不安全的取钱
//两个人去银行取钱，账户
public class UnsafeBank {
    public static void main(String[] args) {
        Account account = new Account(1000, "结婚基金");
        Drawing you = new Drawing(account, 50, "你");
        Drawing girlfriend = new Drawing(account, 100, "girlFriend");
        you.start();
        girlfriend.start();
    }
}

//账户
class Account {
    int money;//余额
    String cardName;//卡名

    public Account(int money, String cardName) {
        this.money = money;
        this.cardName = cardName;
    }
}

//银行:模拟取款
class Drawing extends Thread {
    Account account;//账户
    int drawingMoney;//取金额
    int nowMoney;//你手里的钱

    public Drawing(Account account, int drawingMoney, String name) {
        //调用父类的方法
        super(name);
        this.account = account;
        this.drawingMoney = drawingMoney;

    }

    //取钱  synchronized方法默认锁的是this，但是this是Drawing 而我们要锁的应当是Account（需要cud的操作），因此同步方法起不了作用
    @Override
    public  void run() {
       //锁的对象就是变化的量，需要cud的操作
        synchronized (account) {
            //判断是否有钱
            if (account.money - drawingMoney < 0) {
                System.out.println(Thread.currentThread().getName() + "余额不足,不能进行取钱");
                return;
            }
            try {
                Thread.sleep(1000);//放大问题的发生性
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //卡内金额 = 余额-你的钱
            account.money = account.money - drawingMoney;
            //你手里的钱
            nowMoney = drawingMoney;
            System.out.println(account.cardName + "余额为:" + account.money);
            //this.getName()==super.getName()==Thread.currentThread().getName()
            System.out.println(super.getName() + "手里的钱:" + nowMoney);
        }
    }
}
```

> 输出：

![image-20220202150035010](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220202150035010.png)

> 案例二：解决线程不安全的集合问题

```java
package com.kwq.syn;

import java.util.ArrayList;
import java.util.List;

//线程不安全的集合
public class UnsafeList {
    public static void main(String[] args) throws InterruptedException {
        List<String> list = new ArrayList<String>();
        for (int i = 0; i < 1000; i++) {
            new Thread(()->{
                synchronized (list){
                list.add(Thread.currentThread().getName());}
            }).start();
        }
        Thread.sleep(300);
        System.out.println(list.size());

    }
}
```

> 输出：

![image-20220202150002639](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220202150002639.png)

==PS:案例三中，如果Thread.sleep(300);省略的话，依旧会出现线程不安全的问题，原因是：输出的操作（主线程）总稍微快于最后几步（创建线程和list.add）==



## JUC包下类型安全的集合

==CopyOnWriteArrayList这个集合不需要使用同步代码块也能实现线程安全==

```java
package com.kwq.syn;
import lombok.SneakyThrows;
import java.util.concurrent.CopyOnWriteArrayList;

//测试JUC安全类型的集合
public class TestJUC {
    public static void main(String[] args) throws InterruptedException {
        CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
        for (int i = 0; i < 1000; i++) {
            new Thread(()->{
                list.add(Thread.currentThread().getName());
            }).start();
        }
       Thread.sleep(300);  //让主线程休眠，避免其他线程没走完
        System.out.println(list.size());
    }
}
```

> 输出：

![image-20220202151746068](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220202151746068.png)

## 死锁

多个线程各自占有一些==共享资源==，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形 .某一个同步块
同时拥有==“两个以上对象的锁”==时，就可能会发生“死锁”的问题

> 死锁产生的条件：

产生死锁的四个必要条件：

1. 互斥条件：一个资源(==线程共享资源==)每次只能被一个进程使用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。
4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。
   

> 避免死锁的方法：

上面列出了死锁的四个必要条件，我们只要想办法破其中的任意一个或多个条件
就可以避免死锁发生



> 演示代码：

```java
package com.kwq.syn;

//  死锁:多个线程互相抱着对方需要的资源,然后形成僵持

public class DeadLock {
    public static void main(String[] args) {
        Makeup g1 = new Makeup(0, "灰姑娘");
        Makeup g2 = new Makeup(1, "白雪公主");
        g1.start();
        g2.start();
    }
}

//口红
class Lipstick { }
//镜子
class Mirror { }

class Makeup extends Thread {
    //需要的资源只有一份,用static保证只有一份
    static Lipstick lipstick = new Lipstick();
    static Mirror mirror = new Mirror();
    int choice;//选择
    String girlName;//使用化妆品的人

    public Makeup(int choice, String girlName) {
        this.choice = choice;
        this.girlName = girlName;
    }

    @Override
    public void run() {
        //化妆
        try {
            makeup();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
  //化妆，互相持有对方的锁，就是需要拿到对方的资源
    private void makeup() throws InterruptedException {
        if (choice == 0) {
            synchronized (lipstick) {//获得口红的锁
                System.out.println(this.girlName + "获得口红的锁");
                Thread.sleep(1000);
                synchronized (mirror) {//一秒钟后想获得镜子
                    System.out.println(this.girlName + "获得镜子的锁");
                }
            }
        } else {
            synchronized (mirror) {//获得口红镜子
                System.out.println(this.girlName + "获得镜子的锁");
                Thread.sleep(2000);
                synchronized (lipstick) {//二秒钟后想获得的锁
                    System.out.println(this.girlName + "获得口红的锁");
                }
            }
        }
    }
}
```

> 输出：

![image-20220202161503614](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220202161503614.png)



> 修改代码，解决死锁的问题

```java
package com.kwq.syn;

//  死锁:多个线程互相抱着对方需要的资源,然后形成僵持

public class DeadLock {
    public static void main(String[] args) {
        Makeup g1 = new Makeup(0, "灰姑娘");
        Makeup g2 = new Makeup(1, "白雪公主");
        g1.start();
        g2.start();
    }
}

//口红
class Lipstick { }
//镜子
class Mirror { }

class Makeup extends Thread {
    //需要的资源只有一份,用static保证只有一份
    static Lipstick lipstick = new Lipstick();
    static Mirror mirror = new Mirror();
    int choice;//选择
    String girlName;//使用化妆品的人

    public Makeup(int choice, String girlName) {
        this.choice = choice;
        this.girlName = girlName;
    }

    @Override
    public void run() {
        //化妆
        try {
            makeup();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
  //化妆，互相持有对方的锁，就是需要拿到对方的资源
    private void makeup() throws InterruptedException {
        if (choice == 0) {
            synchronized (lipstick) {//获得口红的锁
                System.out.println(this.girlName + "获得口红的锁");
                Thread.sleep(1000);
            }
            synchronized (mirror) {//一秒钟后想获得镜子
                System.out.println(this.girlName + "获得镜子的锁");
            }
        } else {
            synchronized (mirror) {//获得口红镜子
                System.out.println(this.girlName + "获得镜子的锁");
                Thread.sleep(2000);

                }
            synchronized (lipstick) {//二秒钟后想获得的锁
                System.out.println(this.girlName + "获得口红的锁");
            }
        }
    }
}
```

> 输出：

![image-20220202162241656](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220202162241656.png)



## Lock锁

- 从JDK 5.0开始, Java提供了更强大的==线程同步机制==---------
  通过显式定义`同步锁对象`来实现同步。`同步锁使用Lock对象`
- ==java.util.concurrent.locks.Lock接口是`控制多个线程对共享资源进行访问的工具`==。
  ==锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象==
- `ReentrantLock类`实现了Lock，==它拥有与 synchronized 相同的并发性和内存语义==，在实现线程安全的控制中，比较常用的是ReentrantLock，可以`显式加锁、释放锁`。

> 使用规范：

![image-20220202165245501](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220202165245501.png)

> 未用lock锁之前：

```java
package com.kwq.gaoji;

import java.util.concurrent.locks.ReentrantLock;

public class TestLock {
    public static void main(String[] args) {
        TestLock2 testLock = new TestLock2();
        new Thread(testLock).start();
        new Thread(testLock).start();
        new Thread(testLock).start();
    }
}

class TestLock2 implements Runnable {
    int tickerNums = 10;

    @Override
    public void run() {
        while (true) {
           if (tickerNums>0){
               try {
                   Thread.sleep(1000);
               } catch (InterruptedException e) {
                   e.printStackTrace();
               }
               System.out.println(tickerNums--);
           }else {
               break;
           }

        }
            }
    }
```

> 输出：

![image-20220202165504810](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220202165504810.png)

> 使用lock锁：

```java
package com.kwq.gaoji;

import java.util.concurrent.locks.ReentrantLock;

//测试Lock锁
public class TestLock {
    public static void main(String[] args) {
        TestLock2 testLock = new TestLock2();
        new Thread(testLock).start();
        new Thread(testLock).start();
        new Thread(testLock).start();
    }
}

class TestLock2 implements Runnable {
    int tickerNums = 10;
    //定义Lock锁
    private final ReentrantLock lock = new ReentrantLock();

    @Override
    public void run() {
        while (true) {
            try{
                lock.lock();//加锁

           if (tickerNums>0){

               try {
                   Thread.sleep(1000);
               } catch (InterruptedException e) {
                   e.printStackTrace();
               }
               System.out.println(tickerNums--);
           }else {
               break;
           }

        }finally {
                //解锁
                lock.unlock();
            }
            }
    }
}
```

> 输出：

![image-20220202165401521](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220202165401521.png)

> 结论：==lock实现了线程安全！！！==



## synchronized与Lock的对比

- 
  Lock是显式锁（手动开启和关闭锁，别忘记关闭锁）==synchronized是隐式锁，出了作用域自动释放==

- ==Lock只有代码块锁，synchronized有代码块锁和方法锁==

- ==使用Lock锁,
  JVM将花费较少的时间来调度线程，性能更好。`并且具有更好的扩展性（提供更多的子类）`==

- 优先使用顺序：

  Lock > 同步代码块（==已经进入了方法体，分配了相应资源==）>同步方法（==在方法体之外==)



## 线程通信

> 应用场景：生产者和消费者问题

- 假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将
  仓库中产品取走消费 .
- 如果仓库中没有产品，则生产者将产品放入仓库，否则停止生产并等待，直到
  仓库中的产品被消费者取走为止 .
- 如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，
  直到仓库中再次放入产品为止 .

![image-20220202211256922](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220202211256922.png)

**线程通信分析**

**这是一个线程同步问题,生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件.**

- 对于生产者，没有生产产品之前，要通知消费者等待，而生产了产品之后，又
  需要马上通知消费者消费
- 对于消费者 , 在消费之后，要通知生产者已经结束消费，需要生产新的产品
  以供消费.
- 在生产者消费者问题中，仅有synchronized是不够的
  - synchronized 可阻止并发更新同一个共享资源，实现了同步
  - synchronized 不能用来实现不同线程之间的消息传递（通信）

![image-20220202211204296](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220202211204296.png)



> 解决方式一：管程法

并发协作模型“生产者/消费者模式”--->管程法

- 生产者：负责生产数据的模块（可能是方法，对象 ，线程，进程）；
- 消费者：负责处理数据的模块 (可能是方法，对象 , 线程 , 进程) ;
- 缓冲区：消费者不能直接使用生产者的数据，他们之间有个“缓冲区

**生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据**

![image-20220202211410131](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220202211410131.png)

> 演示代码：

```
package com.kwq.gaoji;
//测试：生产者消费者模型--> 利用缓冲区解决：管程法
// 生产者，消费者，产品，缓冲区
public class TestPC {
    public static void main(String[] args) {
        SynContainer synContainer = new SynContainer();
        new Producer(synContainer).start();
        new Consumer(synContainer).start();
    }
}

//生产者
class Producer extends Thread {
    //容缓冲区
    SynContainer container;

    public Producer(SynContainer container) {
        this.container = container;
    }

    //生产
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            container.push(new Chincken(i));
            System.out.println("生产了" + i + "只鸡");
        }
    }
}

//消费者
class Consumer extends Thread {
    //容缓冲区
    SynContainer container;

    public Consumer(SynContainer container) {
        this.container = container;
    }

    //消费
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println("消费了-->" + container.pop().id + "只鸡");
        }
    }
}

//产品
class Chincken {
    int id;//产品编号

    public Chincken(int id) {
        this.id = id;
    }
}

//缓冲区
class SynContainer {
    //需要一个容器大小
    Chincken[] chinckens = new Chincken[10];
    //容器计数器
    int count = 0;

    //生产者放入产品
    public synchronized void push(Chincken chincken) {
        //如果容器满了,需要等待消费者消费
        if (count==chinckens.length){
            //通知消费者消费，生产等待
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        //如果没有满,需要丢入产品
        chinckens[count]=chincken;
        count++;
        //可以通知消费者消费
        this.notifyAll();

    }

    //消费者消费产品
    public synchronized Chincken pop() {
        //判断是否能消费
        if (count <= 0) {
            //等待生产者生产,消费者等待
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }
        //如果可以消费
        count--;
        Chincken chincken= chinckens[count];
        //吃完了 通知生产者生产
        this.notifyAll();
        return chincken;
    }

}
```

![image-20220203011158916](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220203011158916.png)

> 解决方式二：信号灯法

![image-20220202211441004](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220202211441004.png)

> 演示代码：

```java
package com.kwq.gaoji;
//测试生产者消费者问题2：信号灯法，标志位解决
public class TestPC2 {
    public static void main(String[] args) {
        TV tv = new TV();
        new player(tv).start();
        new Watcher(tv).start();
    }
}

//生产者-->演员
class player extends Thread{
    TV tv;
    public player(TV tv){
        this.tv=tv;
    }

    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            if (i%2==0){
                this.tv.play("快乐大本营播放中");
            }else{
                this.tv.play("抖音：记录美好生活");
            }
        }
    }
}

//消费者-->观众
class Watcher extends Thread{
    TV tv;
    public Watcher(TV tv){
        this.tv=tv;
    }

    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            tv.watch();
        }
    }
}

//产品-->节目
class TV{
    //演员表演，观众等待  T
    //观众观看，演员等待  F
    String voice; //表演的节目
    boolean flag=true;

    //表演
    public synchronized void play(String voice){
        if (!flag){
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        System.out.println("演员表演了:"+voice);

        //通知观众观看
        this.notifyAll(); //通知唤醒
        this.voice=voice;
        this.flag=!this.flag;
    }
    //观看
    public synchronized void watch(){
        if (flag){
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("观看了:"+voice);
        //通知演员表演
        this.notifyAll();
        this.flag=!this.flag;

    }
}
```

> 输出：

![image-20220203013116876](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220203013116876.png)



## 线程池

> 为什么使用线程池：

- 背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。
- 思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。
  可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。
- 好处：
  1. 提高响应速度
     (减少了创建新线程的时间)
  2. 降低资源消耗（重复利用线程池中线程，不需要每次都创建）
  3. 便于线程管理(....)
     - corePoolSize：核心池的大小
     - maximumPoolSize：最大一起跑的线程数
     - keepAliveTime：线程没有任务时最多保持多长时间后会销毁线程池



- JDK 5.0起提供了线程池相关API: **ExecutorService** 和 **Executors**
- ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor
  - void execute(Runnable command)：执行任务/命令，没有返回值，一般用来执
    行Runnable
  - <T> Future<T> submit(Callable<T> task): 执行任务，有返回值，一般用来执行
    Callable
  - void shutdown()关闭连接池
- Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池



> 演示代码：

```java
package com.kwq.gaoji;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

//测试线程池
public class TestPool {
    public static void main(String[] args) {
    // 1. 创建服务,擦行间线程池
    // newFixedThreadPool  参数为线程池大小
    ExecutorService service = Executors.newFixedThreadPool(10);
    //执行
        service.execute(new MyThread());
        service.execute(new MyThread());
        service.execute(new MyThread());
        service.execute(new MyThread());
        service.execute(new MyThread());
        service.execute(new MyThread());
        service.execute(new MyThread());
        service.execute(new MyThread());
        service.execute(new MyThread());
        service.execute(new MyThread());
        service.execute(new MyThread());
    //关闭连接
        service.shutdown();
}

 }
class MyThread implements Runnable {
    @Override
    public void run() {
            System.out.println(Thread.currentThread().getName());


    }

}

```

> 输出：

![image-20220203155514688](C:\Users\19395\AppData\Roaming\Typora\typora-user-images\image-20220203155514688.png)

